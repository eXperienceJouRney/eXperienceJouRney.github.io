[{"title":"[学习存档]ROS中时间相关的API","url":"/2025/10/15/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DROS%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84API/","content":"时间Python1.时刻获取时刻，或是设置指定时刻:\n# 获取当前时刻right_now = rospy.Time.now()rospy.loginfo(&quot;当前时刻:%.2f&quot;,right_now.to_sec())rospy.loginfo(&quot;当前时刻:%.2f&quot;,right_now.to_nsec())# 自定义时刻some_time1 = rospy.Time(1234.567891011)some_time2 = rospy.Time(1234,567891011)rospy.loginfo(&quot;设置时刻1:%.2f&quot;,some_time1.to_sec())rospy.loginfo(&quot;设置时刻2:%.2f&quot;,some_time2.to_sec())# 从时间创建对象# some_time3 = rospy.Time.from_seconds(543.21)some_time3 = rospy.Time.from_sec(543.21) # from_sec 替换了 from_secondsrospy.loginfo(&quot;设置时刻3:%.2f&quot;,some_time3.to_sec())\n\n2.持续时间设置一个时间区间(间隔):\n# 持续时间相关APIrospy.loginfo(&quot;持续时间测试开始.....&quot;)du = rospy.Duration(3.3)rospy.loginfo(&quot;du1 持续时间:%.2f&quot;,du.to_sec())rospy.sleep(du) #休眠函数rospy.loginfo(&quot;持续时间测试结束.....&quot;)\n\n3.持续时间与时刻运算为了方便使用，ROS中提供了时间与时刻的运算:\nrospy.loginfo(&quot;时间运算&quot;)now = rospy.Time.now()du1 = rospy.Duration(10)du2 = rospy.Duration(20)rospy.loginfo(&quot;当前时刻:%.2f&quot;,now.to_sec())before_now = now - du1after_now = now + du1dd = du1 + du2# now = now + now #非法rospy.loginfo(&quot;之前时刻:%.2f&quot;,before_now.to_sec())rospy.loginfo(&quot;之后时刻:%.2f&quot;,after_now.to_sec())rospy.loginfo(&quot;持续时间相加:%.2f&quot;,dd.to_sec())\n\n4.设置运行频率# 设置执行频率rate = rospy.Rate(0.5)while not rospy.is_shutdown():    rate.sleep() #休眠\n\n5.定时器ROS 中内置了专门的定时器，可以实现与 ros::Rate 类似的效果:\n# 定时器设置# @type  callback: function taking rospy.TimerEvent# @param oneshot: 设置为True，就只执行一次，否则循环执行# @type  oneshot: bool# @param reset: if True, timer is reset when rostime moved backward. [default: False]# @type  reset: boolrospy.Timer(rospy.Duration(1),doMsg)# rospy.Timer(rospy.Duration(1),doMsg,True) # 只执行一次rospy.spin()\n\n回调函数:\ndef doMsg(event):  rospy.loginfo(&quot;当前时刻:%s&quot;,str(event.current_real))\n\n6.定时器构造函数说明def __init__(self, period, callback, oneshot=False, reset=False):    &quot;&quot;&quot;    Constructor.    @param period: 回调函数的时间间隔    @type  period: rospy.Duration        @param callback: 回调函数    @type  callback: function taking rospy.TimerEvent        @param oneshot: 设置为True，就只执行一次，否则循环执行    @type  oneshot: bool        @param reset: if True, timer is reset when rostime moved backward. [default: False]    @type  reset: bool    &quot;&quot;&quot;","tags":["ROS"]},{"title":"如果你下午四点钟来，那我在三点钟就会开始感到幸福。","url":"/2025/10/06/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9C%A8%E4%B8%8B%E5%8D%88%E5%9B%9B%E7%82%B9%E9%92%9F%E6%9D%A5%EF%BC%8C%E9%82%A3%E6%88%91%E5%9C%A8%E4%B8%89%E7%82%B9%E9%92%9F%E5%B0%B1%E4%BC%9A%E5%BC%80%E5%A7%8B%E6%84%9F%E5%88%B0%E5%B9%B8%E7%A6%8F%E3%80%82/","content":"该怎么去阐述演唱会的意义呢。我想于真正的歌迷而言，或者至少于我而言，演唱会从来都不只是两三个小时的大型乌托邦，是开票前请各种朋友帮忙的倾尽全力，是抢到票后提前一个月就时不时在内心彩排的预演快乐，是越逼近约定兑现之时越幸福的期待。这大概就是有所望的力量。我还记得2025年9月28日的武汉有多热——赶到场馆已是大汗淋漓。为了应援购入的联名卫衣外套没法穿，拥挤的内场想要拍照记录貌似也不如看台方便。或许我就是这么贪婪的。抢到票前总想着能进场就行，真的坐在内场了，总期待自己能比之前在看台离偶像更近一点，这次能不能看见人呢？答案是还是很远。于是便暗暗下定决心下次一定要买到2000的票。我之前一直对“人总是在接近幸福时最幸福”的说法表示不解，因为我总在幸福时依旧幸福。但这次坐在内场，看着我熟悉的流程一个一个进行下去，熟悉的常驻曲目响起，我确实感到自己并没有开场前幸福了。是太躁热吗？原因在爱你没差响起时明晰了。比较真的是偷走幸福的小偷。抢到票的我与没抢到票的我相比是幸福的，坐在内场后排被无数部举起的手机挡住视线的我与内场前排的观众相比是不幸福的，但听到了爱你没差现场版的我与之前的我相比，又确确实实是无比幸福的。校园里的桂花开了，走在路上很香。让我想起了小时候总喜欢拾落在地上的桂花，或装在盒子里或制成香囊。思绪回到过去，就好奇，到底是什么时候开始不止是听众，而是粉丝的呢？或许真的没有一个特定的日子。只想起初三时，mojito发行，住校的我是靠打电话收听新歌的，是真的很期待。也记得那天校园广播放了mojito，旋律响起时全班人都看向我。在初中同学的回忆里，我大概始终与喜欢周杰伦绑定在一起。谢谢你成为了我的几分之几。\n","tags":["随笔"]},{"title":"[学习存档]ROS通信机制","url":"/2025/10/15/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/","content":"话题通信基本操作流程：\n\n编写发布方实现；\n编写订阅方实现；\n(为python文件添加可执行权限；)\n编辑配置文件；\n编译并执行。\n\n&#x2F;&#x2F;循环发布消息：HelloWorld 后缀数字编号\nC++实现代码1.发布方 Hello_pub.cpp//1.包含头文件#include &quot;ros/ros.h&quot;  //ROS C++ 客户端库#include &quot;std_msgs/String.h&quot;  //普通文本类型的消息#include &lt;sstream&gt;int main(int argc, char *argv[])&#123;\tsetlocale(LC_ALL,&quot;&quot;);  //设置本地化编码防止出现乱码\t\t//2.初始化ROS节点\t//参数3为节点名称\tros::init(argc,argv,&quot;talker&quot;);  \t\t//3.实例化ROS句柄\tros::NodeHandle nh;\t\t//4.实例化**发布者**对象\t//参数1为要发布到的话题\t//参数2:为队列中最大保存的消息数，超出此阀值时，先进的先销毁\tros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;,10);  \t\t//5.组织被发布的数据，并编写逻辑发布数据\tstd_msgs::String msg;  //创建了一个空的字符串消息容器\tstd::string msg_front = &quot;HelloWorld&quot;;  //定义消息的固定前缀部分\tint count = 0;  //定义计数器\t\tros::Rate r(1);  //定义频率为1Hz=1秒1次\t\twhile (ros::ok())&#123;\t\tstd::stringstream ss;\t\t//使用 stringstream 拼接字符串与编号\t\tss &lt;&lt; msg_front &lt;&lt; count;  \t\t\t\tmsg.data = ss.str(); \t\t \t\t//不使用 stringstream，直接拼接\t\t//msg.data = msg_front + std::to_string(count);\t\t\t\t//使用格式化库\t\t//#include &lt;format&gt;\t\t//msg.data = std::format(&quot;&#123;&#125;&#123;&#125;&quot;,msg_front,count);\t\t\t\tpub.publish(msg);  //发布消息\t\t        ROS_INFO(&quot;发送的消息:%s&quot;,msg.data.c_str());  //调试日志\t\t\t\t//调试打印发送的消息        ROS_INFO(&quot;发送的消息:%s&quot;,msg.data.c_str());  //兼容C        //根据频率自动休眠 休眠时间 = 1/频率；        r.sleep();                count++;                ros::spinOnce();\t&#125;\t\treturn 0;\t&#125;\n\n2.订阅方 Hello_sub.cpp// 1.包含头文件 #include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;//传递智能指针而不是字符串 保证性能void doMsg(const std_mags::String::ConstPtr&amp; msg_p)&#123;\tROS_INFO(&quot;我听见:%s&quot;,msg_p -&gt; data.c_str());&#125;  int main()&#123;\tsetlocale(LC_ALL,&quot;&quot;);\t\t//2.初始化ROS节点\tros::init(argc,argv,&quot;listener&quot;);\t//3.实例化ROS句柄\tros::NodeHandle nh;\t\t//4.实例化**订阅者**对象\t\tros::Subscriber sub = nh.subscribe&lt;std_msgs::String&gt;(&quot;chatter&quot;,10,doMsg);\t\t//5.处理订阅的消息（回调函数）\t//void doMsg(const std_mags::String::ConstPtr&amp; msg_p)&#123;\t//ROS_INFO(&quot;我听见:%s&quot;,msg_p -&gt; data.c_str());//&#125; \t//6.设置循环调用回调函数\tros::spin();\t\treturn 0;\t&#125;\n\n3.配置 CMakeLists.txtadd_executable(Hello_pub  src/Hello_pub.cpp)add_executable(Hello_sub  src/Hello_sub.cpp)//链接库文件target_link_libraries(Hello_pub  $&#123;catkin_LIBRARIES&#125;)target_link_libraries(Hello_sub  $&#123;catkin_LIBRARIES&#125;)\n\nPython实现代码1.发布方 Hello_pub.py# 1.导包import rospyfrom std_msgs.msg import Stringif __name__ == &quot;__main__&quot;:\t# 2.初始化ROS节点\trospy.init_node(&quot;talker_p&quot;) \t\t# 3.实例化**发布者**对象\tpub = rospy.Publisher(&quot;chatter&quot;,String.queue_size=10) \t\t# 4.组织被发布的数据，并编写逻辑发布数据\tmsg = String()  # 创建mag对象\tmsg_front = &quot;HelloWorld&quot; #定义消息的固定前缀部分\tcount = 0 #定义计数器\t\trate = rospy.Rate(1)  #定义频率为1Hz=1秒1次\t\twhile not rospy.is_shutdown():\t\tmsg.data = msg_front + str(count) \t\t\t\tpub.publish(msg);  #发布消息\t\t        #根据频率自动休眠 休眠时间 = 1/频率；        rate.sleep()                rospy.loginfo(&quot;写出的数据:%s&quot;,msg.data)                count += 1        \n\n2.订阅方 Hello_sub.py#1.导包 import rospyfrom std_msgs.msg import Stringdef doMsg(msg):    rospy.loginfo(&quot;我听见:%s&quot;,msg.data)if __name__ == &quot;__main__&quot;:    #2.初始化 ROS 节点:命名(唯一)    rospy.init_node(&quot;listener_p&quot;)        #3.实例化 订阅者 对象    sub = rospy.Subscriber(&quot;chatter&quot;,String,doMsg,queue_size=10)        #4.处理订阅的消息(回调函数)        #5.设置循环调用回调函数    rospy.spin()\n\n3.权限设置终端下进入 scripts 执行:chmod +x *.py\n4.配置 CMakeLists.txtcatkin_install_python(PROGRAMS  scripts/Hello_pub.py  scripts/Hello_sub.py  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)\n\n执行1.启动 roscore\nroscore\n\n2.启动发布节点\n//进入工作空间目录cd ~/catkin_ws//source环境source devel/setup.bash//运行发布节点rosrun Hello Hello_pub\n\n3.启动订阅节点\n//进入工作空间目录cd ~/catkin_ws//source环境source devel/setup.bash//运行订阅节点rosrun Hello Hello_sub\n\n验证1.查看运行的节点\nrosnode list\n\n2.查看话题\nrostopic list\n\n3.查看话题内容\nrostopic echo /topic_name\n\n4.查看节点信息\nrosnode info /node_name\n\n自定义msg流程:\n\n按照固定格式创建 msg 文件\n编辑配置文件\n编译生成可以被 Python 或 C++ 调用的中间文件\n\n&#x2F;&#x2F;需求:创建自定义消息，该消息包含人的信息:姓名、身高、年龄等。\n1.定义msg文件功能包下新建 msg 目录，添加文件 Person.msg\nstring nameuint16 agefloat64 height\n\n2.编辑配置文件package.xml中添加编译依赖与执行依赖\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\nCMakeLists.txt编辑 msg 相关配置\nfind_package(catkin REQUIRED COMPONENTS  roscpp  rospy  std_msgs  message_generation)//需要加入 message_generation,必须有 std_msgs\n\n//配置 msg 源文件add_message_files(  FILES  Person.msg)\n\n//生成消息时依赖于 std_msgsgenerate_messages(  DEPENDENCIES  std_msgs)\n\ncatkin_package(  INCLUDE_DIRS include //指定头文件目录  LIBRARIES demo02_talker_listener //指定库文件  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime //执行时依赖  DEPENDS system_lib  //声明非ROS的系统依赖)\n\n3.调用0.vscode 配置为了方便代码提示以及避免误抛异常，需要先将前面生成的文件路径配置:\nC++：将前面生成的头文件路径配置进 c_cpp_properties.json 的 includepath属性\n&#123;    &quot;configurations&quot;: [        &#123;            &quot;browse&quot;: &#123;                &quot;databaseFilename&quot;: &quot;&quot;,                &quot;limitSymbolsToIncludedHeaders&quot;: true            &#125;,            &quot;includePath&quot;: [                &quot;/opt/ros/noetic/include/**&quot;,                &quot;/usr/include/**&quot;,                &quot;/xxx/yyy工作空间/devel/include/**&quot; //配置 head 文件的路径             ],            &quot;name&quot;: &quot;ROS&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;,            &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;,            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;        &#125;    ],    &quot;version&quot;: 4&#125;\n\n2.Python：将前面生成的 python 文件路径配置进 settings.json\n&#123;    &quot;python.autoComplete.extraPaths&quot;: [        &quot;/opt/ros/noetic/lib/python3/dist-packages&quot;,        &quot;/xxx/yyy工作空间/devel/lib/python3/dist-packages&quot;    ]&#125;\n\n1.发布方C++\n#include &quot;demo_talker_listener/Person.h&quot;demo_talker_listener::Person p;p.name = &quot;XJR&quot;;p.age = 2000;p.height = 1.6;\n\nPython:\nfrom demo_talker_listener.msg import Personp = Person()p.name = &quot;XJR&quot;p.age = 18p.height = 2.8\n\n2.订阅方C++\n#include &quot;demo_talker_listener/Person.h&quot;void doPerson(const demo_talker_listener::Person::ConstPtr&amp; person_p)&#123;    ROS_INFO(&quot;订阅的人信息:%s, %d, %.2f&quot;, person_p-&gt;name.c_str(), person_p-&gt;age, person_p-&gt;height);&#125;ros::Subscriber sub = nh.subscribe&lt;demo_talker_listener::Person&gt;(&quot;chatter_person&quot;,10,doPerson);\n\nPython:\nfrom demo_talker_listener.msg import Persondef doPerson(p):    rospy.loginfo(&quot;订阅的人的信息:%s, %d, %.2f&quot;,p.name, p.age, p.height)\n\n服务通信需求:\n\n服务通信中，客户端提交两个整数至服务端，服务端求和并响应结果到客户端，请创建服务器与客户端通信的数据载体。\n\n流程:\nsrv 文件内的可用数据类型与 msg 文件一致，且定义 srv 实现流程与自定义 msg 实现流程类似:\n\n按照固定格式创建srv文件\n\n编辑配置文件\n\n编译生成中间文件\n\n\n1.自定义srv服务通信中，数据分成两部分，请求与响应，在 srv 文件中请求和响应使用---分割，具体实现如下：\n功能包下新建 srv 目录，添加 xxx.srv 文件，内容：\n# 客户端请求时发送的两个数字int32 num1int32 num2---# 服务器响应发送的数据int32 sum\n\npackage.xml中添加编译依赖与执行依赖\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\nCMakeLists.txt 编辑 srv 相关配置\nfind_package(catkin REQUIRED COMPONENTS  roscpp  rospy  std_msgs  message_generation)\n\nadd_service_files(  FILES  AddInts.srv)\n\ngenerate_messages(  DEPENDENCIES  std_msgs)\n\n编译后的中间文件查看:\nC++ 需要调用的中间文件(…&#x2F;工作空间&#x2F;devel&#x2F;include&#x2F;包名&#x2F;xxx.h)\nPython 需要调用的中间文件(…&#x2F;工作空间&#x2F;devel&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;包名&#x2F;srv)\n2.C++实现调用流程:\n\n编写服务端实现；\n编写客户端实现；\n编辑配置文件；\n编译并执行。\n\n0.vscode配置需要像之前自定义 msg 实现一样配置c_cpp_properies.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同。\n1.服务端#include &quot;ros/ros.h&quot;#include &quot;demo_server_client/AddInts.h&quot;// bool 返回值由于标志是否处理成功bool doReq(demo_server_client::AddInts::Request&amp; req,          demo_server_client::AddInts::Response&amp; resp)&#123;    int num1 = req.num1;    int num2 = req.num2;    ROS_INFO(&quot;服务器接收到的请求数据为:num1 = %d, num2 = %d&quot;,num1, num2);    //逻辑处理    if (num1 &lt; 0 || num2 &lt; 0)    &#123;        ROS_ERROR(&quot;提交的数据异常:数据不可以为负数&quot;);        return false;    &#125;    //如果没有异常，那么相加并将结果赋值给 resp    resp.sum = num1 + num2;        return true;&#125;int main(int argc, char *argv[])&#123;    setlocale(LC_ALL,&quot;&quot;);        // 2.初始化 ROS 节点    ros::init(argc,argv,&quot;AddInts_Server&quot;);        // 3.创建 ROS 句柄    ros::NodeHandle nh;        // 4.创建 服务 对象    ros::ServiceServer server = nh.advertiseService(&quot;AddInts&quot;,doReq);        ROS_INFO(&quot;服务已经启动....&quot;);        // 5.回调函数处理请求并产生响应        // 6.由于请求有多个，需要调用 ros::spin()    ros::spin();    return 0;&#125;\n\n2.客户端// 1.包含头文件#include &quot;ros/ros.h&quot;#include &quot;demo_server_client/AddInts.h&quot;int main(int argc, char *argv[])&#123;    setlocale(LC_ALL,&quot;&quot;);    if (argc != 3)    // 直接命令行运行并传参 (1节点名称 2传入的参数 3传入的参数)        // if (argc != 5)    //launch 传参(0-文件路径 1传入的参数 2传入的参数 3节点名称 4日志路径)    &#123;        ROS_ERROR(&quot;请提交两个整数&quot;);        return 1;    &#125;    // 2.初始化 ROS 节点    ros::init(argc,argv,&quot;AddInts_Client&quot;);        // 3.创建 ROS 句柄    ros::NodeHandle nh;        // 4.创建 客户端 对象    ros::ServiceClient client = nh.serviceClient&lt;demo_server_client::AddInts&gt;(&quot;AddInts&quot;);        //等待服务启动成功        //方式1    ros::service::waitForService(&quot;AddInts&quot;);        //方式2    // client.waitForExistence();        // 5.组织请求数据    demo_server_client::AddInts si;        int64_t num1 = std::stoll(argv[1]);    int64_t num2 = std::stoll(argv[2]);    si.request.num1 = num1;    si.request.num2 = num2;    ROS_INFO(&quot;准备发送请求: num1=%ld, num2=%ld&quot;, num1, num2);    // 6.发送请求,返回 bool 值，标记是否成功    bool flag = client.call(si);        // 7.处理响应    if (flag)    &#123;        ROS_INFO(&quot;请求正常处理,响应结果:%d&quot;,si.response.sum);    &#125;    else    &#123;        ROS_ERROR(&quot;请求处理失败....&quot;);        return 1;    &#125;    return 0;&#125;\n\n3.配置 CMakeLists.txtadd_executable(AddInts_Server src/AddInts_Server.cpp)add_executable(AddInts_Client src/AddInts_Client.cpp)add_dependencies(AddInts_Server $&#123;PROJECT_NAME&#125;_gencpp)add_dependencies(AddInts_Client $&#123;PROJECT_NAME&#125;_gencpp)target_link_libraries(AddInts_Server  $&#123;catkin_LIBRARIES&#125;)target_link_libraries(AddInts_Client  $&#123;catkin_LIBRARIES&#125;)\n\n\n3.Python实现调用流程:\n\n编写服务端实现；\n编写客户端实现；\n为python文件添加可执行权限；\n编辑配置文件；\n编译并执行。\n\n0.vscode配置需要像之前自定义 msg 实现一样配置settings.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同.\n1.服务端# 1.导包import rospyfrom demo_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse# 回调函数的参数是请求对象，返回值是响应对象def doReq(req):    # 解析提交的数据    sum = req.num1 + req.num2    rospy.loginfo(&quot;提交的数据:num1 = %d, num2 = %d, sum = %d&quot;,req.num1, req.num2, sum)    # 创建响应对象，赋值并返回    # resp = AddIntsResponse()    # resp.sum = sum    resp = AddIntsResponse(sum)    return respif __name__ == &quot;__main__&quot;:    # 2.初始化 ROS 节点    rospy.init_node(&quot;addints_server_p&quot;)        # 3.创建服务对象    server = rospy.Service(&quot;AddInts&quot;,AddInts,doReq)        # 4.回调函数处理请求并产生响应        # 5.spin 函数    rospy.spin()\n\n2.客户端#1.导包import rospyfrom demo_server_client.srv import *import sysif __name__ == &quot;__main__&quot;:    #优化实现    if len(sys.argv) != 3:        rospy.logerr(&quot;请正确提交参数&quot;)        sys.exit(1)    # 2.初始化 ROS 节点    rospy.init_node(&quot;AddInts_Client_p&quot;)        # 3.创建请求对象    client = rospy.ServiceProxy(&quot;AddInts&quot;,AddInts)        # 请求前，等待服务已经就绪        # 方式1:    # rospy.wait_for_service(&quot;AddInts&quot;)        # 方式2    client.wait_for_service()        # 4.发送请求,接收并处理响应        # 方式1    # resp = client(3,4)        # 方式2    # resp = client(AddIntsRequest(1,5))        # 方式3    req = AddIntsRequest()    # req.num1 = 100    # req.num2 = 200     #优化    req.num1 = int(sys.argv[1])    req.num2 = int(sys.argv[2])     resp = client.call(req)        rospy.loginfo(&quot;响应结果:%d&quot;,resp.sum)\n\n3.设置权限终端下进入 scripts 执行:chmod +x *.py\n4.配置 CMakeLists.txtCMakeLists.txt\ncatkin_install_python(PROGRAMS  scripts/AddInts_Server_p.py   scripts/AddInts_Client_p.py  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)\n\n4.执行流程:\n\n需要先启动服务:rosrun 包名 服务\n\n然后再调用客户端 :rosrun 包名 客户端 参数1 参数2\n\n\n结果:\n会根据提交的数据响应相加后的结果。\n参数服务器1.理论模型1.Talker 设置参数Talker 通过 RPC 向参数服务器发送参数(包括参数名与参数值)，ROS Master 将参数保存到参数列表中。\n2.Listener 获取参数Listener 通过 RPC 向参数服务器发送参数查找请求，请求中包含要查找的参数名。\n3.ROS Master 向 Listener 发送参数值ROS Master 根据步骤2请求提供的参数名查找参数值，并将查询结果通过 RPC 发送给 Listener。\n2.C++参数操作**需求:**实现参数服务器参数的增删改查操作。\n在 C++ 中实现参数服务器数据的增删改查，可以通过两套 API 实现:\n\nros::NodeHandle\n\nros::param\n\n\n1.参数服务器新增(修改)参数#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123;    ros::init(argc,argv,&quot;set_update_param&quot;);    std::vector&lt;std::string&gt; stus;    stus.push_back(&quot;no&quot;);    stus.push_back(&quot;one&quot;);    stus.push_back(&quot;but&quot;);    stus.push_back(&quot;you&quot;);    std::map&lt;std::string,std::string&gt; friends;    friends[&quot;chiikawa&quot;] = &quot;usagi&quot;;    friends[&quot;hachiware&quot;] = &quot;chiikawa&quot;;\n\n//NodeHandleros::NodeHandle nh;nh.setParam(&quot;nh_int&quot;,10); //整型nh.setParam(&quot;nh_double&quot;,3.14); //浮点型nh.setParam(&quot;nh_bool&quot;,true); //boolnh.setParam(&quot;nh_string&quot;,&quot;hello NodeHandle&quot;); //字符串nh.setParam(&quot;nh_vector&quot;,stus); // vectornh.setParam(&quot;nh_map&quot;,friends); // map//修改演示(相同的键，不同的值)nh.setParam(&quot;nh_int&quot;,10000);\n\n//paramros::param::set(&quot;param_int&quot;,20);ros::param::set(&quot;param_double&quot;,3.14);ros::param::set(&quot;param_string&quot;,&quot;Hello Param&quot;);ros::param::set(&quot;param_bool&quot;,false);ros::param::set(&quot;param_vector&quot;,stus);ros::param::set(&quot;param_map&quot;,friends);//修改演示(相同的键，不同的值)ros::param::set(&quot;param_int&quot;,20000);\n\n    return 0;&#125;\n\n2.参数服务器获取参数参数服务器操作之查询_C++实现:        param(键,默认值)            存在，返回对应结果，否则返回默认值\n    getParam(键,存储结果的变量)\n        存在,返回 true,且将值赋值给参数2\n        若键不存在，那么返回值为 false，且不为参数2赋值\n\n    getParamCached(键,存储结果的变量)--提高变量获取效率\n        存在,返回 true,且将值赋值给参数2\n        若键不存在，那么返回值为 false，且不为参数2赋值\n\n    getParamNames(std::vector&lt;std::string&gt;)\n        获取所有的键,并存储在参数 vector 中 \n\n    hasParam(键)\n        是否包含某个键，存在返回 true，否则返回 false\n\n    searchParam(参数1，参数2)\n        搜索键，参数1是被搜索的键，参数2存储搜索结果的变量\n\n#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123;    setlocale(LC_ALL,&quot;&quot;);    ros::init(argc,argv,&quot;get_param&quot;);\n\n//NodeHandleros::NodeHandle nh;// param 函数int res1 = nh.param(&quot;nh_int&quot;,100); // 键存在int res2 = nh.param(&quot;nh_int2&quot;,100); // 键不存在ROS_INFO(&quot;param获取结果:%d,%d&quot;,res1,res2);// getParam 函数int nh_int_value;double nh_double_value;bool nh_bool_value;std::string nh_string_value;std::vector&lt;std::string&gt; stus;std::map&lt;std::string, std::string&gt; friends;nh.getParam(&quot;nh_int&quot;,nh_int_value);nh.getParam(&quot;nh_double&quot;,nh_double_value);nh.getParam(&quot;nh_bool&quot;,nh_bool_value);nh.getParam(&quot;nh_string&quot;,nh_string_value);nh.getParam(&quot;nh_vector&quot;,stus);nh.getParam(&quot;nh_map&quot;,friends);ROS_INFO(&quot;getParam获取的结果:%d,%.2f,%s,%d&quot;,        nh_int_value,        nh_double_value,        nh_string_value.c_str(),        nh_bool_value        );        for (auto &amp;&amp;stu : stus)&#123;    ROS_INFO(&quot;stus 元素:%s&quot;,stu.c_str());        &#125;for (auto &amp;&amp;f : friends)&#123;    ROS_INFO(&quot;map 元素:%s = %s&quot;,f.first.c_str(), f.second.c_str());&#125;// getParamCached()nh.getParamCached(&quot;nh_int&quot;,nh_int_value);ROS_INFO(&quot;通过缓存获取数据:%d&quot;,nh_int_value);//getParamNames()std::vector&lt;std::string&gt; param_names1;nh.getParamNames(param_names1);for (auto &amp;&amp;name : param_names1)&#123;    ROS_INFO(&quot;名称解析name = %s&quot;,name.c_str());        &#125;ROS_INFO(&quot;存在 nh_int 吗? %d&quot;,nh.hasParam(&quot;nh_int&quot;));ROS_INFO(&quot;存在 nh_intttt 吗? %d&quot;,nh.hasParam(&quot;nh_intttt&quot;));std::string key;nh.searchParam(&quot;nh_int&quot;,key);ROS_INFO(&quot;搜索键:%s&quot;,key.c_str());\n\n//paramint res3 = ros::param::param(&quot;param_int&quot;,20); //存在int res4 = ros::param::param(&quot;param_int2&quot;,20); // 不存在返回默认ROS_INFO(&quot;param获取结果:%d,%d&quot;,res3,res4);// getParam 函数int param_int_value;double param_double_value;bool param_bool_value;std::string param_string_value;std::vector&lt;std::string&gt; param_stus;std::map&lt;std::string, std::string&gt; param_friends;ros::param::get(&quot;param_int&quot;,param_int_value);ros::param::get(&quot;param_double&quot;,param_double_value);ros::param::get(&quot;param_bool&quot;,param_bool_value);ros::param::get(&quot;param_string&quot;,param_string_value);ros::param::get(&quot;param_vector&quot;,param_stus);ros::param::get(&quot;param_map&quot;,param_friends);ROS_INFO(&quot;getParam获取的结果:%d,%.2f,%s,%d&quot;,        param_int_value,        param_double_value,        param_string_value.c_str(),        param_bool_value        );for (auto &amp;&amp;stu : param_stus)&#123;    ROS_INFO(&quot;stus 元素:%s&quot;,stu.c_str());        &#125;for (auto &amp;&amp;f : param_friends)&#123;    ROS_INFO(&quot;map 元素:%s = %s&quot;,f.first.c_str(), f.second.c_str());&#125;// getParamCached()ros::param::getCached(&quot;param_int&quot;,param_int_value);ROS_INFO(&quot;通过缓存获取数据:%d&quot;,param_int_value);//getParamNames()std::vector&lt;std::string&gt; param_names2;ros::param::getParamNames(param_names2);for (auto &amp;&amp;name : param_names2)&#123;    ROS_INFO(&quot;名称解析name = %s&quot;,name.c_str());        &#125;ROS_INFO(&quot;存在 param_int 吗? %d&quot;,ros::param::has(&quot;param_int&quot;));ROS_INFO(&quot;存在 param_intttt 吗? %d&quot;,ros::param::has(&quot;param_intttt&quot;));std::string key;ros::param::search(&quot;param_int&quot;,key);ROS_INFO(&quot;搜索键:%s&quot;,key.c_str());\n\n    return 0;&#125;\n\n3.参数服务器删除参数#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123;       setlocale(LC_ALL,&quot;&quot;);    ros::init(argc,argv,&quot;delete_param&quot;);    ros::NodeHandle nh;    bool r1 = nh.deleteParam(&quot;nh_int&quot;);    ROS_INFO(&quot;nh 删除结果:%d&quot;,r1);    bool r2 = ros::param::del(&quot;param_int&quot;);    ROS_INFO(&quot;param 删除结果:%d&quot;,r2);    return 0;&#125;\n\n3.Python参数操作1.参数服务器新增(修改)参数import rospyif __name__ == &quot;__main__&quot;:    rospy.init_node(&quot;set_update_paramter_p&quot;)    # 设置各种类型参数    rospy.set_param(&quot;p_int&quot;,10)    rospy.set_param(&quot;p_double&quot;,3.14)    rospy.set_param(&quot;p_bool&quot;,True)    rospy.set_param(&quot;p_string&quot;,&quot;hello python&quot;)    rospy.set_param(&quot;p_list&quot;,[&quot;hello&quot;,&quot;haha&quot;,&quot;xixi&quot;])    rospy.set_param(&quot;p_dict&quot;,&#123;&quot;name&quot;:&quot;Jay&quot;,&quot;age&quot;:8&#125;)    # 修改    rospy.set_param(&quot;p_int&quot;,100)\n\n2.参数服务器获取参数import rospyif __name__ == &quot;__main__&quot;:    rospy.init_node(&quot;get_param_p&quot;)    #获取参数    int_value = rospy.get_param(&quot;p_int&quot;,10000)    double_value = rospy.get_param(&quot;p_double&quot;)    bool_value = rospy.get_param(&quot;p_bool&quot;)    string_value = rospy.get_param(&quot;p_string&quot;)    p_list = rospy.get_param(&quot;p_list&quot;)    p_dict = rospy.get_param(&quot;p_dict&quot;)    rospy.loginfo(&quot;获取的数据:%d,%.2f,%d,%s&quot;,                int_value,                double_value,                bool_value,                string_value)                    for ele in p_list:        rospy.loginfo(&quot;ele = %s&quot;, ele)    rospy.loginfo(&quot;name = %s, age = %d&quot;,p_dict[&quot;name&quot;],p_dict[&quot;age&quot;])    # get_param_cached    int_cached = rospy.get_param_cached(&quot;p_int&quot;)    rospy.loginfo(&quot;缓存数据:%d&quot;,int_cached)    # get_param_names    names = rospy.get_param_names()    for name in names:        rospy.loginfo(&quot;name = %s&quot;,name)    # has_param    flag = rospy.has_param(&quot;p_int&quot;)    rospy.loginfo(&quot;包含p_int吗？%d&quot;,flag)    # search_param    key = rospy.search_param(&quot;p_int&quot;)    rospy.loginfo(&quot;搜索的键 = %s&quot;,key)\n\n3.参数服务器删除参数import rospyif __name__ == &quot;__main__&quot;:    rospy.init_node(&quot;delete_param_p&quot;)    try:        rospy.delete_param(&quot;p_int&quot;)    except Exception as e:        rospy.loginfo(&quot;删除失败&quot;)\n\n\n初始化def init_node(name, argv=None, anonymous=False, log_level=None, disable_rostime=False, disable_rosout=False, disable_signals=False, xmlrpc_port=0, tcpros_port=0):    &quot;&quot;&quot;    在ROS master中注册节点    @param name: 节点名称，必须保证节点名称唯一，节点名称中不能使用命名空间(不能包含 &#x27;/&#x27;)    @type  name: str    @param argv: 命令行参数列表，通常传入sys.argv，用于处理启动参数    @type  argv: list    @param anonymous: 取值为 true 时，为节点名称后缀随机编号，允许多个同名节点同时运行    @type  anonymous: bool    @param log_level: 日志级别，可选值：rospy.DEBUG, rospy.INFO, rospy.WARN, rospy.ERROR, rospy.FATAL    @type  log_level: int    @param disable_rostime: 如果为 true，禁用ROS时间系统，使用系统时间而不是ROS时间    @type  disable_rostime: bool    @param disable_rosout: 如果为 true，禁用rosout日志系统，减少日志输出    @type  disable_rosout: bool    @param disable_signals: 如果为 true，禁用ROS信号处理，需要手动处理信号    @type  disable_signals: bool    @param xmlrpc_port: XML-RPC通信端口，0表示自动分配，用于与ROS master通信    @type  xmlrpc_port: int    @param tcpros_port: TCP-ROS通信端口，0表示自动分配，用于节点间通信    @type  tcpros_port: int    @raise ROSException: 如果节点初始化失败    @raise ROSNodeException: 如果节点名称无效或已存在    &quot;&quot;&quot;\n\n话题与服务相关对象Python1.发布对象对象获取:class Publisher(Topic):    &quot;&quot;&quot;    在ROS master注册为相关话题的发布方    &quot;&quot;&quot;    def __init__(self, name, data_class, subscriber_listener=None, tcp_nodelay=False, latch=False, headers=None, queue_size=None):        &quot;&quot;&quot;        Constructor        @param name: 话题名称，指定要发布的话题名称，不能为空        @type  name: str                @param data_class: 消息类型，指定要发布的消息类型，必须是ROS消息类        @type  data_class: 消息类        @param subscriber_listener: 订阅者监听器，用于监听订阅者的连接和断开事件        @type  subscriber_listener: SubscriberListener        @param tcp_nodelay: 如果为 true，启用TCP_NODELAY选项，减少网络延迟但可能增加网络负载        @type  tcp_nodelay: bool        @param latch: 如果为 true,该话题发布的最后一条消息将被保存，并且后期当有订阅者连接时会将该消息发送给订阅者        @type  latch: bool        @param headers: 消息头部信息，为消息添加默认的头部信息        @type  headers: dict        @param queue_size: 等待发送给订阅者的最大消息数量，控制内存使用和消息丢失        @type  queue_size: int        @raise ROSException: 如果发布者创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n消息发布函数:def publish(self, *args, **kwds):        &quot;&quot;&quot;        发布消息        &quot;&quot;&quot;\n\n2.订阅对象对象获取:class Subscriber(Topic):    &quot;&quot;&quot;    类注册为指定主题的订阅者，其中消息是给定类型的。    &quot;&quot;&quot;    def __init__(self, name, data_class, callback=None, callback_args=None,                 queue_size=None, buff_size=DEFAULT_BUFF_SIZE, tcp_nodelay=False):        &quot;&quot;&quot;        Constructor.        @param name: 话题名称，指定要订阅的话题名称，不能为空        @type  name: str                @param data_class: 消息类型，指定要订阅的消息类型，必须是ROS消息类        @type  data_class: L&#123;Message&#125; class                @param callback: 处理订阅到的消息的回调函数，当收到消息时自动调用        @type  callback: fn(msg, cb_args)        @param callback_args: 传递给回调函数的额外参数，用于向回调函数传递自定义数据        @type  callback_args: any        @param queue_size: 消息队列长度，超出长度时，头部的消息将被弃用，控制消息缓存大小        @type  queue_size: int        @param buff_size: 缓冲区大小，用于网络传输的缓冲区大小，影响网络性能        @type  buff_size: int        @param tcp_nodelay: 如果为 true，启用TCP_NODELAY选项，减少网络延迟但可能增加网络负载        @type  tcp_nodelay: bool        @raise ROSException: 如果订阅者创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n3.服务对象对象获取:class Service(ServiceImpl):    &quot;&quot;&quot;     声明一个ROS服务    使用示例::      s = Service(&#x27;getmapservice&#x27;, GetMap, get_map_handler)    &quot;&quot;&quot;    def __init__(self, name, service_class, handler,                 buff_size=DEFAULT_BUFF_SIZE, error_handler=None):        &quot;&quot;&quot;        Constructor        @param name: 服务主题名称，指定要创建的服务名称，不能为空        @type  name: str                @param service_class: 服务消息类型，指定服务的请求和响应消息类型        @type  service_class: L&#123;Service&#125; class        @param handler: 回调函数，处理请求数据，并返回响应数据，当收到服务请求时自动调用        @type  handler: fn(req)-&gt;resp        @param buff_size: 缓冲区大小，用于网络传输的缓冲区大小，影响网络性能        @type  buff_size: int        @param error_handler: 错误处理函数，当服务处理过程中发生错误时调用        @type  error_handler: fn(exception)-&gt;None        @raise ROSException: 如果服务创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n4.客户端对象对象获取:class ServiceProxy(_Service):    &quot;&quot;&quot;   创建一个ROS服务的句柄    示例用法::      add_two_ints = ServiceProxy(&#x27;add_two_ints&#x27;, AddTwoInts)      resp = add_two_ints(1, 2)    &quot;&quot;&quot;    def __init__(self, name, service_class, persistent=False, headers=None):        &quot;&quot;&quot;        ctor.        @param name: 服务主题名称，指定要调用的服务名称，不能为空        @type  name: str        @param service_class: 服务消息类型，指定服务的请求和响应消息类型        @type  service_class: Service class        @param persistent: 如果为 true，保持连接，避免重复建立连接的开销        @type  persistent: bool        @param headers: 消息头部信息，为服务请求添加默认的头部信息        @type  headers: dict        @raise ROSException: 如果服务代理创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n请求发送函数:def call(self, *args, **kwds):        &quot;&quot;&quot;        发送请求，返回值为响应数据\t\t@param *args: 位置参数，按顺序传递服务请求的字段值        @type  *args: tuple        @param **kwds: 关键字参数，通过字段名传递服务请求的值        @type  **kwds: dict        @return: 服务响应对象，包含服务处理结果        @rtype: 响应消息类型        @raise ROSException: 如果服务调用失败        @raise ROSServiceException: 如果服务不存在或调用超时        &quot;&quot;&quot;\n\n等待服务函数:def wait_for_service(service, timeout=None):    &quot;&quot;&quot;    调用该函数时，程序会处于阻塞状态直到服务可用        @param service: 被等待的服务话题名称    @type  service: str   \t@param timeout: 超时时间    @type  timeout: double|rospy.Duration    &quot;&quot;&quot;\n","tags":["ROS"]},{"title":"[学习存档]ROS运行管理","url":"/2025/10/18/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DROS%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86/","content":"1. 元功能包 Metapackage1.1 概念一个 metapackage 本身不包含任何实际的软件、文件或代码。它只是一个空的或几乎空的软件包，其唯一目的是定义一组依赖关系。当你安装一个 metapackage 时，你的包管理器（如 apt 或 dnf）会读取这个包的依赖列表，然后自动下载并安装它所依赖的所有其他软件包。\n1.2 作用方便用户的安装。\n1.3 实现\n新建一个功能包\n修改package.xml，内容如下:\n\n&lt;exec_depend&gt;被集成的功能包&lt;/exec_depend&gt;...&lt;export&gt;  &lt;metapackage /&gt;&lt;/export&gt;\n\n\n修改 CMakeLists.txt，内容如下:\n\ncmake_minimum_required(VERSION 3.0.2)project(demo)find_package(catkin REQUIRED)catkin_metapackage()\n\n注意: CMakeLists.txt 中不可以有换行。\n2. 节点运行管理 launch文件2.1 概念launch 文件是一个 XML 格式的文件，可以启动本地和远程的多个节点，还可以在参数服务器中设置参数。\n2.2 作用简化节点的配置与启动，提高ROS程序的启动效率。\n2.3 使用以 turtlesim 为例演示。\n2.3.1 新建launch文件在功能包下添加 launch 目录，目录下新建 xxxx.launch 文件，编辑 launch 文件：\n&lt;launch&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot;     name=&quot;myTurtle&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot;  name=&quot;myTurtleContro&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt;\n\n2.3.2 调用 launch 文件roslaunch 包名 xxx.launch\n\n当执行 roslaunch 时，它会自动检查当前系统是否已经运行了 roscore：\n\n如果 roscore 已经运行：roslaunch 会直接使用现有的 Master，不会重复启动。\n如果 roscore 未运行：roslaunch 会自动启动一个新的 roscore，然后再启动 Launch 文件中定义的节点。\n\n这一行为是隐式的，用户无需手动干预。\n目的：\n\n避免重复启动：\n\nROS 1 的架构要求同一台机器上只能有一个 roscore 在运行。如果多个 roscore 同时存在，会导致节点通信混乱。\nroslaunch 的自动检测机制避免了用户手动管理 roscore 的启动和关闭。\n\n\n简化用户体验：\n\n用户无需关心 roscore 是否已启动，直接运行 roslaunch 即可保证 ROS 系统正常工作。\n尤其对新手友好，降低了入门门槛。\n\n\n保证节点通信一致性：\n\n所有通过 roslaunch 启动的节点会连接到同一个 roscore，确保它们能互相发现并通信。\n\n\n\n2.4 标签2.4.1 &lt;launch&gt;&lt;launch&gt;标签是所有 launch 文件的根标签，充当其他标签的容器。\n\ndeprecated = &quot;弃用声明&quot;：告知用户当前 launch 文件已经弃用\n\n2.4.2 &lt;node&gt;&lt;node&gt;标签用于指定 ROS 节点，是最常见的标签。需要注意：roslaunch 命令不能保证按照 node 的声明顺序来启动节点，节点的启动是多进程的。\n\npkg=&quot;包名&quot;：节点所属的包\ntype=&quot;nodeType&quot;：节点类型(与之相同名称的可执行文件)\nname=&quot;nodeName&quot;：节点名称(在 ROS 网络拓扑中节点的名称)\nargs=&quot;xxx xxx xxx&quot; (可选)：将参数传递给节点\nmachine=&quot;机器名&quot;：在指定机器上启动节点\nrespawn=&quot;true | false&quot; (可选)：如果节点退出，是否自动重启\nrespawn_delay=&quot;N&quot; (可选)：如果 respawn 为 true，那么延迟 N 秒后启动节点\nrequired=&quot;true | false&quot; (可选)：该节点是否必须，如果为 true，那么如果该节点退出，将杀死整个 roslaunch\nns=&quot;xxx&quot; (可选)：在指定命名空间 xxx 中启动节点\nclear_params=&quot;true | false&quot; (可选)：在启动前，删除节点的私有空间的所有参数\noutput=&quot;log | screen&quot; (可选)：日志发送目标，可以设置为 log 日志文件，或 screen 屏幕，默认是 log\n\n2.4.3 &lt;include&gt;include标签用于将另一个 xml 格式的 launch 文件导入到当前文件。\n\nfile=&quot;$(find 包名)/xxx/xxx.launch&quot;：要包含的文件路径\nns=&quot;xxx&quot; (可选)：在指定命名空间导入文件\n\n2.4.4 &lt;remap&gt;用于话题重命名。\n\nfrom=&quot;xxx&quot;：原始话题名称\nto=&quot;yyy&quot;：目标名称\n\n2.4.5 &lt;param&gt;&lt;param&gt;标签主要用于在参数服务器上设置参数，参数源可以在标签中通过 value 指定，也可以通过外部文件加载，在&lt;node&gt;标签中时，相当于私有命名空间。\n\nname=&quot;命名空间/参数名&quot;：参数名称，可以包含命名空间\nvalue=&quot;xxx&quot; (可选)：定义参数值，如果此处省略，必须指定外部文件作为参数源\ntype=&quot;str | int | double | bool | yaml&quot; (可选)：指定参数类型，如果未指定，roslaunch 会尝试确定参数类型，规则如下：\n包含 ‘.’ 的数字解析为浮点型，否则为整型\n“true” 和 “false” 是 bool 值(不区分大小写)\n其他是字符串\n\n\n\n2.4.6 &lt;rosparam&gt;&lt;rosparam&gt;标签可以从 YAML 文件导入参数，或将参数导出到 YAML 文件，也可以用来删除参数，&lt;rosparam&gt;标签在&lt;node&gt;标签中时被视为私有。\n\ncommand=&quot;load | dump | delete&quot; (可选，默认 load)：加载、导出或删除参数\nfile=&quot;$(find xxxxx)/xxx/yyy....&quot;：加载或导出到的 yaml 文件\nparam=&quot;参数名称&quot;\nns=&quot;命名空间&quot; (可选)\n\n2.4.7 &lt;group&gt;&lt;group&gt;标签可以对节点分组，具有 ns 属性，可以让节点归属某个命名空间。\n\nns=&quot;名称空间&quot; (可选)\nclear_params=&quot;true | false&quot; (可选)：启动前，是否删除组名称空间的所有参数(慎用)\n\n2.4.8 &lt;arg&gt;&lt;arg&gt;标签是用于动态传参，类似于函数的参数，可以增强launch文件的灵活性。\n\nname=&quot;参数名称&quot;\ndefault=&quot;默认值&quot; (可选)\nvalue=&quot;数值&quot; (可选)：不可以与 default 并存\ndoc=&quot;描述&quot;\n\nlaunch文件传参示例：\n&lt;launch&gt;    &lt;arg name=&quot;xxx&quot; /&gt;    &lt;param name=&quot;param&quot; value=&quot;$(arg xxx)&quot; /&gt;&lt;/launch&gt;\n\n命令行调用launch传参：\nroslaunch hello.launch xxx:=值\n\n3. 工作空间覆盖所谓工作空间覆盖，是指不同工作空间中，存在重名的功能包的情形。\n3.1 实现\n新建工作空间A与工作空间B，两个工作空间中都创建功能包: turtlesim。\n\n在 ~&#x2F;.bashrc 文件下追加当前工作空间的 bash 格式如下:\n\n\nsource /home/用户/路径/工作空间A/devel/setup.bashsource /home/用户/路径/工作空间B/devel/setup.bash\n\n\n新开命令行: source .bashrc 加载环境变量\n\n查看ROS环境环境变量 echo $ROS_PACKAGE_PATH\n\n\n结果: 自定义工作空间B:自定义空间A:系统内置空间\n\n调用命令: roscd turtlesim 会进入自定义工作空间B\n\n3.2 原因ROS 会解析 .bashrc 文件，并生成 ROS_PACKAGE_PATH ROS包路径，该变量中按照 .bashrc 中配置设置工作空间优先级，在设置时需要遵循一定的原则：\nROS_PACKAGE_PATH 中的值，和 .bashrc 的配置顺序相反 —&gt; 后配置的优先级更高。如果更改自定义空间A与自定义空间B的source顺序，那么调用时，将进入工作空间A。\n3.3 结论功能包重名时，会按照 ROS_PACKAGE_PATH 查找，配置在前的会优先执行。\n\nBUG 说明: \n\n当在 .bashrc 文件中 source 多个工作空间后，可能出现在 ROS PACKAGE PATH 中只包含两个工作空间的情况，可以删除自定义工作空间的 build 与 devel 目录，重新 catkin_make，然后重新载入 .bashrc 文件，问题解决。\n\n","tags":["ROS"]}]