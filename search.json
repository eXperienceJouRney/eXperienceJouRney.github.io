[{"title":"[学习存档]ROS中时间相关的API","url":"/2025/10/15/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DROS%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84API/","content":"时间Python1.时刻获取时刻，或是设置指定时刻:\n# 获取当前时刻right_now = rospy.Time.now()rospy.loginfo(&quot;当前时刻:%.2f&quot;,right_now.to_sec())rospy.loginfo(&quot;当前时刻:%.2f&quot;,right_now.to_nsec())# 自定义时刻some_time1 = rospy.Time(1234.567891011)some_time2 = rospy.Time(1234,567891011)rospy.loginfo(&quot;设置时刻1:%.2f&quot;,some_time1.to_sec())rospy.loginfo(&quot;设置时刻2:%.2f&quot;,some_time2.to_sec())# 从时间创建对象# some_time3 = rospy.Time.from_seconds(543.21)some_time3 = rospy.Time.from_sec(543.21) # from_sec 替换了 from_secondsrospy.loginfo(&quot;设置时刻3:%.2f&quot;,some_time3.to_sec())\n\n2.持续时间设置一个时间区间(间隔):\n# 持续时间相关APIrospy.loginfo(&quot;持续时间测试开始.....&quot;)du = rospy.Duration(3.3)rospy.loginfo(&quot;du1 持续时间:%.2f&quot;,du.to_sec())rospy.sleep(du) #休眠函数rospy.loginfo(&quot;持续时间测试结束.....&quot;)\n\n3.持续时间与时刻运算为了方便使用，ROS中提供了时间与时刻的运算:\nrospy.loginfo(&quot;时间运算&quot;)now = rospy.Time.now()du1 = rospy.Duration(10)du2 = rospy.Duration(20)rospy.loginfo(&quot;当前时刻:%.2f&quot;,now.to_sec())before_now = now - du1after_now = now + du1dd = du1 + du2# now = now + now #非法rospy.loginfo(&quot;之前时刻:%.2f&quot;,before_now.to_sec())rospy.loginfo(&quot;之后时刻:%.2f&quot;,after_now.to_sec())rospy.loginfo(&quot;持续时间相加:%.2f&quot;,dd.to_sec())\n\n4.设置运行频率# 设置执行频率rate = rospy.Rate(0.5)while not rospy.is_shutdown():    rate.sleep() #休眠\n\n5.定时器ROS 中内置了专门的定时器，可以实现与 ros::Rate 类似的效果:\n# 定时器设置# @type  callback: function taking rospy.TimerEvent# @param oneshot: 设置为True，就只执行一次，否则循环执行# @type  oneshot: bool# @param reset: if True, timer is reset when rostime moved backward. [default: False]# @type  reset: boolrospy.Timer(rospy.Duration(1),doMsg)# rospy.Timer(rospy.Duration(1),doMsg,True) # 只执行一次rospy.spin()\n\n回调函数:\ndef doMsg(event):  rospy.loginfo(&quot;当前时刻:%s&quot;,str(event.current_real))\n\n6.定时器构造函数说明def __init__(self, period, callback, oneshot=False, reset=False):    &quot;&quot;&quot;    Constructor.    @param period: 回调函数的时间间隔    @type  period: rospy.Duration        @param callback: 回调函数    @type  callback: function taking rospy.TimerEvent        @param oneshot: 设置为True，就只执行一次，否则循环执行    @type  oneshot: bool        @param reset: if True, timer is reset when rostime moved backward. [default: False]    @type  reset: bool    &quot;&quot;&quot;","tags":["ROS"]},{"title":"[学习存档]ROS通信机制","url":"/2025/10/15/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/","content":"话题通信基本操作流程：\n\n编写发布方实现；\n编写订阅方实现；\n(为python文件添加可执行权限；)\n编辑配置文件；\n编译并执行。\n\n&#x2F;&#x2F;循环发布消息：HelloWorld 后缀数字编号\nC++实现代码1.发布方 Hello_pub.cpp//1.包含头文件#include &quot;ros/ros.h&quot;  //ROS C++ 客户端库#include &quot;std_msgs/String.h&quot;  //普通文本类型的消息#include &lt;sstream&gt;int main(int argc, char *argv[])&#123;\tsetlocale(LC_ALL,&quot;&quot;);  //设置本地化编码防止出现乱码\t\t//2.初始化ROS节点\t//参数3为节点名称\tros::init(argc,argv,&quot;talker&quot;);  \t\t//3.实例化ROS句柄\tros::NodeHandle nh;\t\t//4.实例化**发布者**对象\t//参数1为要发布到的话题\t//参数2:为队列中最大保存的消息数，超出此阀值时，先进的先销毁\tros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;,10);  \t\t//5.组织被发布的数据，并编写逻辑发布数据\tstd_msgs::String msg;  //创建了一个空的字符串消息容器\tstd::string msg_front = &quot;HelloWorld&quot;;  //定义消息的固定前缀部分\tint count = 0;  //定义计数器\t\tros::Rate r(1);  //定义频率为1Hz=1秒1次\t\twhile (ros::ok())&#123;\t\tstd::stringstream ss;\t\t//使用 stringstream 拼接字符串与编号\t\tss &lt;&lt; msg_front &lt;&lt; count;  \t\t\t\tmsg.data = ss.str(); \t\t \t\t//不使用 stringstream，直接拼接\t\t//msg.data = msg_front + std::to_string(count);\t\t\t\t//使用格式化库\t\t//#include &lt;format&gt;\t\t//msg.data = std::format(&quot;&#123;&#125;&#123;&#125;&quot;,msg_front,count);\t\t\t\tpub.publish(msg);  //发布消息\t\t        ROS_INFO(&quot;发送的消息:%s&quot;,msg.data.c_str());  //调试日志\t\t\t\t//调试打印发送的消息        ROS_INFO(&quot;发送的消息:%s&quot;,msg.data.c_str());  //兼容C        //根据频率自动休眠 休眠时间 = 1/频率；        r.sleep();                count++;                ros::spinOnce();\t&#125;\t\treturn 0;\t&#125;\n\n2.订阅方 Hello_sub.cpp// 1.包含头文件 #include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;//传递智能指针而不是字符串 保证性能void doMsg(const std_mags::String::ConstPtr&amp; msg_p)&#123;\tROS_INFO(&quot;我听见:%s&quot;,msg_p -&gt; data.c_str());&#125;  int main()&#123;\tsetlocale(LC_ALL,&quot;&quot;);\t\t//2.初始化ROS节点\tros::init(argc,argv,&quot;listener&quot;);\t//3.实例化ROS句柄\tros::NodeHandle nh;\t\t//4.实例化**订阅者**对象\t\tros::Subscriber sub = nh.subscribe&lt;std_msgs::String&gt;(&quot;chatter&quot;,10,doMsg);\t\t//5.处理订阅的消息（回调函数）\t//void doMsg(const std_mags::String::ConstPtr&amp; msg_p)&#123;\t//ROS_INFO(&quot;我听见:%s&quot;,msg_p -&gt; data.c_str());//&#125; \t//6.设置循环调用回调函数\tros::spin();\t\treturn 0;\t&#125;\n\n3.配置 CMakeLists.txtadd_executable(Hello_pub  src/Hello_pub.cpp)add_executable(Hello_sub  src/Hello_sub.cpp)//链接库文件target_link_libraries(Hello_pub  $&#123;catkin_LIBRARIES&#125;)target_link_libraries(Hello_sub  $&#123;catkin_LIBRARIES&#125;)\n\nPython实现代码1.发布方 Hello_pub.py# 1.导包import rospyfrom std_msgs.msg import Stringif __name__ == &quot;__main__&quot;:\t# 2.初始化ROS节点\trospy.init_node(&quot;talker_p&quot;) \t\t# 3.实例化**发布者**对象\tpub = rospy.Publisher(&quot;chatter&quot;,String.queue_size=10) \t\t# 4.组织被发布的数据，并编写逻辑发布数据\tmsg = String()  # 创建mag对象\tmsg_front = &quot;HelloWorld&quot; #定义消息的固定前缀部分\tcount = 0 #定义计数器\t\trate = rospy.Rate(1)  #定义频率为1Hz=1秒1次\t\twhile not rospy.is_shutdown():\t\tmsg.data = msg_front + str(count) \t\t\t\tpub.publish(msg);  #发布消息\t\t        #根据频率自动休眠 休眠时间 = 1/频率；        rate.sleep()                rospy.loginfo(&quot;写出的数据:%s&quot;,msg.data)                count += 1        \n\n2.订阅方 Hello_sub.py#1.导包 import rospyfrom std_msgs.msg import Stringdef doMsg(msg):    rospy.loginfo(&quot;我听见:%s&quot;,msg.data)if __name__ == &quot;__main__&quot;:    #2.初始化 ROS 节点:命名(唯一)    rospy.init_node(&quot;listener_p&quot;)        #3.实例化 订阅者 对象    sub = rospy.Subscriber(&quot;chatter&quot;,String,doMsg,queue_size=10)        #4.处理订阅的消息(回调函数)        #5.设置循环调用回调函数    rospy.spin()\n\n3.权限设置终端下进入 scripts 执行:chmod +x *.py\n4.配置 CMakeLists.txtcatkin_install_python(PROGRAMS  scripts/Hello_pub.py  scripts/Hello_sub.py  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)\n\n执行1.启动 roscore\nroscore\n\n2.启动发布节点\n//进入工作空间目录cd ~/catkin_ws//source环境source devel/setup.bash//运行发布节点rosrun Hello Hello_pub\n\n3.启动订阅节点\n//进入工作空间目录cd ~/catkin_ws//source环境source devel/setup.bash//运行订阅节点rosrun Hello Hello_sub\n\n验证1.查看运行的节点\nrosnode list\n\n2.查看话题\nrostopic list\n\n3.查看话题内容\nrostopic echo /topic_name\n\n4.查看节点信息\nrosnode info /node_name\n\n自定义msg流程:\n\n按照固定格式创建 msg 文件\n编辑配置文件\n编译生成可以被 Python 或 C++ 调用的中间文件\n\n&#x2F;&#x2F;需求:创建自定义消息，该消息包含人的信息:姓名、身高、年龄等。\n1.定义msg文件功能包下新建 msg 目录，添加文件 Person.msg\nstring nameuint16 agefloat64 height\n\n2.编辑配置文件package.xml中添加编译依赖与执行依赖\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\nCMakeLists.txt编辑 msg 相关配置\nfind_package(catkin REQUIRED COMPONENTS  roscpp  rospy  std_msgs  message_generation)//需要加入 message_generation,必须有 std_msgs\n\n//配置 msg 源文件add_message_files(  FILES  Person.msg)\n\n//生成消息时依赖于 std_msgsgenerate_messages(  DEPENDENCIES  std_msgs)\n\ncatkin_package(  INCLUDE_DIRS include //指定头文件目录  LIBRARIES demo02_talker_listener //指定库文件  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime //执行时依赖  DEPENDS system_lib  //声明非ROS的系统依赖)\n\n3.调用0.vscode 配置为了方便代码提示以及避免误抛异常，需要先将前面生成的文件路径配置:\nC++：将前面生成的头文件路径配置进 c_cpp_properties.json 的 includepath属性\n&#123;    &quot;configurations&quot;: [        &#123;            &quot;browse&quot;: &#123;                &quot;databaseFilename&quot;: &quot;&quot;,                &quot;limitSymbolsToIncludedHeaders&quot;: true            &#125;,            &quot;includePath&quot;: [                &quot;/opt/ros/noetic/include/**&quot;,                &quot;/usr/include/**&quot;,                &quot;/xxx/yyy工作空间/devel/include/**&quot; //配置 head 文件的路径             ],            &quot;name&quot;: &quot;ROS&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;,            &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;,            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;        &#125;    ],    &quot;version&quot;: 4&#125;\n\n2.Python：将前面生成的 python 文件路径配置进 settings.json\n&#123;    &quot;python.autoComplete.extraPaths&quot;: [        &quot;/opt/ros/noetic/lib/python3/dist-packages&quot;,        &quot;/xxx/yyy工作空间/devel/lib/python3/dist-packages&quot;    ]&#125;\n\n1.发布方C++\n#include &quot;demo_talker_listener/Person.h&quot;demo_talker_listener::Person p;p.name = &quot;XJR&quot;;p.age = 2000;p.height = 1.6;\n\nPython:\nfrom demo_talker_listener.msg import Personp = Person()p.name = &quot;XJR&quot;p.age = 18p.height = 2.8\n\n2.订阅方C++\n#include &quot;demo_talker_listener/Person.h&quot;void doPerson(const demo_talker_listener::Person::ConstPtr&amp; person_p)&#123;    ROS_INFO(&quot;订阅的人信息:%s, %d, %.2f&quot;, person_p-&gt;name.c_str(), person_p-&gt;age, person_p-&gt;height);&#125;ros::Subscriber sub = nh.subscribe&lt;demo_talker_listener::Person&gt;(&quot;chatter_person&quot;,10,doPerson);\n\nPython:\nfrom demo_talker_listener.msg import Persondef doPerson(p):    rospy.loginfo(&quot;订阅的人的信息:%s, %d, %.2f&quot;,p.name, p.age, p.height)\n\n服务通信需求:\n\n服务通信中，客户端提交两个整数至服务端，服务端求和并响应结果到客户端，请创建服务器与客户端通信的数据载体。\n\n流程:\nsrv 文件内的可用数据类型与 msg 文件一致，且定义 srv 实现流程与自定义 msg 实现流程类似:\n\n按照固定格式创建srv文件\n\n编辑配置文件\n\n编译生成中间文件\n\n\n1.自定义srv服务通信中，数据分成两部分，请求与响应，在 srv 文件中请求和响应使用---分割，具体实现如下：\n功能包下新建 srv 目录，添加 xxx.srv 文件，内容：\n# 客户端请求时发送的两个数字int32 num1int32 num2---# 服务器响应发送的数据int32 sum\n\npackage.xml中添加编译依赖与执行依赖\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\nCMakeLists.txt 编辑 srv 相关配置\nfind_package(catkin REQUIRED COMPONENTS  roscpp  rospy  std_msgs  message_generation)\n\nadd_service_files(  FILES  AddInts.srv)\n\ngenerate_messages(  DEPENDENCIES  std_msgs)\n\n编译后的中间文件查看:\nC++ 需要调用的中间文件(…&#x2F;工作空间&#x2F;devel&#x2F;include&#x2F;包名&#x2F;xxx.h)\nPython 需要调用的中间文件(…&#x2F;工作空间&#x2F;devel&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;包名&#x2F;srv)\n2.C++实现调用流程:\n\n编写服务端实现；\n编写客户端实现；\n编辑配置文件；\n编译并执行。\n\n0.vscode配置需要像之前自定义 msg 实现一样配置c_cpp_properies.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同。\n1.服务端#include &quot;ros/ros.h&quot;#include &quot;demo_server_client/AddInts.h&quot;// bool 返回值由于标志是否处理成功bool doReq(demo_server_client::AddInts::Request&amp; req,          demo_server_client::AddInts::Response&amp; resp)&#123;    int num1 = req.num1;    int num2 = req.num2;    ROS_INFO(&quot;服务器接收到的请求数据为:num1 = %d, num2 = %d&quot;,num1, num2);    //逻辑处理    if (num1 &lt; 0 || num2 &lt; 0)    &#123;        ROS_ERROR(&quot;提交的数据异常:数据不可以为负数&quot;);        return false;    &#125;    //如果没有异常，那么相加并将结果赋值给 resp    resp.sum = num1 + num2;        return true;&#125;int main(int argc, char *argv[])&#123;    setlocale(LC_ALL,&quot;&quot;);        // 2.初始化 ROS 节点    ros::init(argc,argv,&quot;AddInts_Server&quot;);        // 3.创建 ROS 句柄    ros::NodeHandle nh;        // 4.创建 服务 对象    ros::ServiceServer server = nh.advertiseService(&quot;AddInts&quot;,doReq);        ROS_INFO(&quot;服务已经启动....&quot;);        // 5.回调函数处理请求并产生响应        // 6.由于请求有多个，需要调用 ros::spin()    ros::spin();    return 0;&#125;\n\n2.客户端// 1.包含头文件#include &quot;ros/ros.h&quot;#include &quot;demo_server_client/AddInts.h&quot;int main(int argc, char *argv[])&#123;    setlocale(LC_ALL,&quot;&quot;);    if (argc != 3)    // 直接命令行运行并传参 (1节点名称 2传入的参数 3传入的参数)        // if (argc != 5)    //launch 传参(0-文件路径 1传入的参数 2传入的参数 3节点名称 4日志路径)    &#123;        ROS_ERROR(&quot;请提交两个整数&quot;);        return 1;    &#125;    // 2.初始化 ROS 节点    ros::init(argc,argv,&quot;AddInts_Client&quot;);        // 3.创建 ROS 句柄    ros::NodeHandle nh;        // 4.创建 客户端 对象    ros::ServiceClient client = nh.serviceClient&lt;demo_server_client::AddInts&gt;(&quot;AddInts&quot;);        //等待服务启动成功        //方式1    ros::service::waitForService(&quot;AddInts&quot;);        //方式2    // client.waitForExistence();        // 5.组织请求数据    demo_server_client::AddInts si;        int64_t num1 = std::stoll(argv[1]);    int64_t num2 = std::stoll(argv[2]);    si.request.num1 = num1;    si.request.num2 = num2;    ROS_INFO(&quot;准备发送请求: num1=%ld, num2=%ld&quot;, num1, num2);    // 6.发送请求,返回 bool 值，标记是否成功    bool flag = client.call(si);        // 7.处理响应    if (flag)    &#123;        ROS_INFO(&quot;请求正常处理,响应结果:%d&quot;,si.response.sum);    &#125;    else    &#123;        ROS_ERROR(&quot;请求处理失败....&quot;);        return 1;    &#125;    return 0;&#125;\n\n3.配置 CMakeLists.txtadd_executable(AddInts_Server src/AddInts_Server.cpp)add_executable(AddInts_Client src/AddInts_Client.cpp)add_dependencies(AddInts_Server $&#123;PROJECT_NAME&#125;_gencpp)add_dependencies(AddInts_Client $&#123;PROJECT_NAME&#125;_gencpp)target_link_libraries(AddInts_Server  $&#123;catkin_LIBRARIES&#125;)target_link_libraries(AddInts_Client  $&#123;catkin_LIBRARIES&#125;)\n\n\n3.Python实现调用流程:\n\n编写服务端实现；\n编写客户端实现；\n为python文件添加可执行权限；\n编辑配置文件；\n编译并执行。\n\n0.vscode配置需要像之前自定义 msg 实现一样配置settings.json 文件，如果以前已经配置且没有变更工作空间，可以忽略，如果需要配置，配置方式与之前相同.\n1.服务端# 1.导包import rospyfrom demo_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse# 回调函数的参数是请求对象，返回值是响应对象def doReq(req):    # 解析提交的数据    sum = req.num1 + req.num2    rospy.loginfo(&quot;提交的数据:num1 = %d, num2 = %d, sum = %d&quot;,req.num1, req.num2, sum)    # 创建响应对象，赋值并返回    # resp = AddIntsResponse()    # resp.sum = sum    resp = AddIntsResponse(sum)    return respif __name__ == &quot;__main__&quot;:    # 2.初始化 ROS 节点    rospy.init_node(&quot;addints_server_p&quot;)        # 3.创建服务对象    server = rospy.Service(&quot;AddInts&quot;,AddInts,doReq)        # 4.回调函数处理请求并产生响应        # 5.spin 函数    rospy.spin()\n\n2.客户端#1.导包import rospyfrom demo_server_client.srv import *import sysif __name__ == &quot;__main__&quot;:    #优化实现    if len(sys.argv) != 3:        rospy.logerr(&quot;请正确提交参数&quot;)        sys.exit(1)    # 2.初始化 ROS 节点    rospy.init_node(&quot;AddInts_Client_p&quot;)        # 3.创建请求对象    client = rospy.ServiceProxy(&quot;AddInts&quot;,AddInts)        # 请求前，等待服务已经就绪        # 方式1:    # rospy.wait_for_service(&quot;AddInts&quot;)        # 方式2    client.wait_for_service()        # 4.发送请求,接收并处理响应        # 方式1    # resp = client(3,4)        # 方式2    # resp = client(AddIntsRequest(1,5))        # 方式3    req = AddIntsRequest()    # req.num1 = 100    # req.num2 = 200     #优化    req.num1 = int(sys.argv[1])    req.num2 = int(sys.argv[2])     resp = client.call(req)        rospy.loginfo(&quot;响应结果:%d&quot;,resp.sum)\n\n3.设置权限终端下进入 scripts 执行:chmod +x *.py\n4.配置 CMakeLists.txtCMakeLists.txt\ncatkin_install_python(PROGRAMS  scripts/AddInts_Server_p.py   scripts/AddInts_Client_p.py  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)\n\n4.执行流程:\n\n需要先启动服务:rosrun 包名 服务\n\n然后再调用客户端 :rosrun 包名 客户端 参数1 参数2\n\n\n结果:\n会根据提交的数据响应相加后的结果。\n参数服务器1.理论模型1.Talker 设置参数Talker 通过 RPC 向参数服务器发送参数(包括参数名与参数值)，ROS Master 将参数保存到参数列表中。\n2.Listener 获取参数Listener 通过 RPC 向参数服务器发送参数查找请求，请求中包含要查找的参数名。\n3.ROS Master 向 Listener 发送参数值ROS Master 根据步骤2请求提供的参数名查找参数值，并将查询结果通过 RPC 发送给 Listener。\n2.C++参数操作**需求:**实现参数服务器参数的增删改查操作。\n在 C++ 中实现参数服务器数据的增删改查，可以通过两套 API 实现:\n\nros::NodeHandle\n\nros::param\n\n\n1.参数服务器新增(修改)参数#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123;    ros::init(argc,argv,&quot;set_update_param&quot;);    std::vector&lt;std::string&gt; stus;    stus.push_back(&quot;no&quot;);    stus.push_back(&quot;one&quot;);    stus.push_back(&quot;but&quot;);    stus.push_back(&quot;you&quot;);    std::map&lt;std::string,std::string&gt; friends;    friends[&quot;chiikawa&quot;] = &quot;usagi&quot;;    friends[&quot;hachiware&quot;] = &quot;chiikawa&quot;;\n\n//NodeHandleros::NodeHandle nh;nh.setParam(&quot;nh_int&quot;,10); //整型nh.setParam(&quot;nh_double&quot;,3.14); //浮点型nh.setParam(&quot;nh_bool&quot;,true); //boolnh.setParam(&quot;nh_string&quot;,&quot;hello NodeHandle&quot;); //字符串nh.setParam(&quot;nh_vector&quot;,stus); // vectornh.setParam(&quot;nh_map&quot;,friends); // map//修改演示(相同的键，不同的值)nh.setParam(&quot;nh_int&quot;,10000);\n\n//paramros::param::set(&quot;param_int&quot;,20);ros::param::set(&quot;param_double&quot;,3.14);ros::param::set(&quot;param_string&quot;,&quot;Hello Param&quot;);ros::param::set(&quot;param_bool&quot;,false);ros::param::set(&quot;param_vector&quot;,stus);ros::param::set(&quot;param_map&quot;,friends);//修改演示(相同的键，不同的值)ros::param::set(&quot;param_int&quot;,20000);\n\n    return 0;&#125;\n\n2.参数服务器获取参数参数服务器操作之查询_C++实现:        param(键,默认值)            存在，返回对应结果，否则返回默认值\n    getParam(键,存储结果的变量)\n        存在,返回 true,且将值赋值给参数2\n        若键不存在，那么返回值为 false，且不为参数2赋值\n\n    getParamCached(键,存储结果的变量)--提高变量获取效率\n        存在,返回 true,且将值赋值给参数2\n        若键不存在，那么返回值为 false，且不为参数2赋值\n\n    getParamNames(std::vector&lt;std::string&gt;)\n        获取所有的键,并存储在参数 vector 中 \n\n    hasParam(键)\n        是否包含某个键，存在返回 true，否则返回 false\n\n    searchParam(参数1，参数2)\n        搜索键，参数1是被搜索的键，参数2存储搜索结果的变量\n\n#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123;    setlocale(LC_ALL,&quot;&quot;);    ros::init(argc,argv,&quot;get_param&quot;);\n\n//NodeHandleros::NodeHandle nh;// param 函数int res1 = nh.param(&quot;nh_int&quot;,100); // 键存在int res2 = nh.param(&quot;nh_int2&quot;,100); // 键不存在ROS_INFO(&quot;param获取结果:%d,%d&quot;,res1,res2);// getParam 函数int nh_int_value;double nh_double_value;bool nh_bool_value;std::string nh_string_value;std::vector&lt;std::string&gt; stus;std::map&lt;std::string, std::string&gt; friends;nh.getParam(&quot;nh_int&quot;,nh_int_value);nh.getParam(&quot;nh_double&quot;,nh_double_value);nh.getParam(&quot;nh_bool&quot;,nh_bool_value);nh.getParam(&quot;nh_string&quot;,nh_string_value);nh.getParam(&quot;nh_vector&quot;,stus);nh.getParam(&quot;nh_map&quot;,friends);ROS_INFO(&quot;getParam获取的结果:%d,%.2f,%s,%d&quot;,        nh_int_value,        nh_double_value,        nh_string_value.c_str(),        nh_bool_value        );        for (auto &amp;&amp;stu : stus)&#123;    ROS_INFO(&quot;stus 元素:%s&quot;,stu.c_str());        &#125;for (auto &amp;&amp;f : friends)&#123;    ROS_INFO(&quot;map 元素:%s = %s&quot;,f.first.c_str(), f.second.c_str());&#125;// getParamCached()nh.getParamCached(&quot;nh_int&quot;,nh_int_value);ROS_INFO(&quot;通过缓存获取数据:%d&quot;,nh_int_value);//getParamNames()std::vector&lt;std::string&gt; param_names1;nh.getParamNames(param_names1);for (auto &amp;&amp;name : param_names1)&#123;    ROS_INFO(&quot;名称解析name = %s&quot;,name.c_str());        &#125;ROS_INFO(&quot;存在 nh_int 吗? %d&quot;,nh.hasParam(&quot;nh_int&quot;));ROS_INFO(&quot;存在 nh_intttt 吗? %d&quot;,nh.hasParam(&quot;nh_intttt&quot;));std::string key;nh.searchParam(&quot;nh_int&quot;,key);ROS_INFO(&quot;搜索键:%s&quot;,key.c_str());\n\n//paramint res3 = ros::param::param(&quot;param_int&quot;,20); //存在int res4 = ros::param::param(&quot;param_int2&quot;,20); // 不存在返回默认ROS_INFO(&quot;param获取结果:%d,%d&quot;,res3,res4);// getParam 函数int param_int_value;double param_double_value;bool param_bool_value;std::string param_string_value;std::vector&lt;std::string&gt; param_stus;std::map&lt;std::string, std::string&gt; param_friends;ros::param::get(&quot;param_int&quot;,param_int_value);ros::param::get(&quot;param_double&quot;,param_double_value);ros::param::get(&quot;param_bool&quot;,param_bool_value);ros::param::get(&quot;param_string&quot;,param_string_value);ros::param::get(&quot;param_vector&quot;,param_stus);ros::param::get(&quot;param_map&quot;,param_friends);ROS_INFO(&quot;getParam获取的结果:%d,%.2f,%s,%d&quot;,        param_int_value,        param_double_value,        param_string_value.c_str(),        param_bool_value        );for (auto &amp;&amp;stu : param_stus)&#123;    ROS_INFO(&quot;stus 元素:%s&quot;,stu.c_str());        &#125;for (auto &amp;&amp;f : param_friends)&#123;    ROS_INFO(&quot;map 元素:%s = %s&quot;,f.first.c_str(), f.second.c_str());&#125;// getParamCached()ros::param::getCached(&quot;param_int&quot;,param_int_value);ROS_INFO(&quot;通过缓存获取数据:%d&quot;,param_int_value);//getParamNames()std::vector&lt;std::string&gt; param_names2;ros::param::getParamNames(param_names2);for (auto &amp;&amp;name : param_names2)&#123;    ROS_INFO(&quot;名称解析name = %s&quot;,name.c_str());        &#125;ROS_INFO(&quot;存在 param_int 吗? %d&quot;,ros::param::has(&quot;param_int&quot;));ROS_INFO(&quot;存在 param_intttt 吗? %d&quot;,ros::param::has(&quot;param_intttt&quot;));std::string key;ros::param::search(&quot;param_int&quot;,key);ROS_INFO(&quot;搜索键:%s&quot;,key.c_str());\n\n    return 0;&#125;\n\n3.参数服务器删除参数#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123;       setlocale(LC_ALL,&quot;&quot;);    ros::init(argc,argv,&quot;delete_param&quot;);    ros::NodeHandle nh;    bool r1 = nh.deleteParam(&quot;nh_int&quot;);    ROS_INFO(&quot;nh 删除结果:%d&quot;,r1);    bool r2 = ros::param::del(&quot;param_int&quot;);    ROS_INFO(&quot;param 删除结果:%d&quot;,r2);    return 0;&#125;\n\n3.Python参数操作1.参数服务器新增(修改)参数import rospyif __name__ == &quot;__main__&quot;:    rospy.init_node(&quot;set_update_paramter_p&quot;)    # 设置各种类型参数    rospy.set_param(&quot;p_int&quot;,10)    rospy.set_param(&quot;p_double&quot;,3.14)    rospy.set_param(&quot;p_bool&quot;,True)    rospy.set_param(&quot;p_string&quot;,&quot;hello python&quot;)    rospy.set_param(&quot;p_list&quot;,[&quot;hello&quot;,&quot;haha&quot;,&quot;xixi&quot;])    rospy.set_param(&quot;p_dict&quot;,&#123;&quot;name&quot;:&quot;Jay&quot;,&quot;age&quot;:8&#125;)    # 修改    rospy.set_param(&quot;p_int&quot;,100)\n\n2.参数服务器获取参数import rospyif __name__ == &quot;__main__&quot;:    rospy.init_node(&quot;get_param_p&quot;)    #获取参数    int_value = rospy.get_param(&quot;p_int&quot;,10000)    double_value = rospy.get_param(&quot;p_double&quot;)    bool_value = rospy.get_param(&quot;p_bool&quot;)    string_value = rospy.get_param(&quot;p_string&quot;)    p_list = rospy.get_param(&quot;p_list&quot;)    p_dict = rospy.get_param(&quot;p_dict&quot;)    rospy.loginfo(&quot;获取的数据:%d,%.2f,%d,%s&quot;,                int_value,                double_value,                bool_value,                string_value)                    for ele in p_list:        rospy.loginfo(&quot;ele = %s&quot;, ele)    rospy.loginfo(&quot;name = %s, age = %d&quot;,p_dict[&quot;name&quot;],p_dict[&quot;age&quot;])    # get_param_cached    int_cached = rospy.get_param_cached(&quot;p_int&quot;)    rospy.loginfo(&quot;缓存数据:%d&quot;,int_cached)    # get_param_names    names = rospy.get_param_names()    for name in names:        rospy.loginfo(&quot;name = %s&quot;,name)    # has_param    flag = rospy.has_param(&quot;p_int&quot;)    rospy.loginfo(&quot;包含p_int吗？%d&quot;,flag)    # search_param    key = rospy.search_param(&quot;p_int&quot;)    rospy.loginfo(&quot;搜索的键 = %s&quot;,key)\n\n3.参数服务器删除参数import rospyif __name__ == &quot;__main__&quot;:    rospy.init_node(&quot;delete_param_p&quot;)    try:        rospy.delete_param(&quot;p_int&quot;)    except Exception as e:        rospy.loginfo(&quot;删除失败&quot;)\n\n\n初始化def init_node(name, argv=None, anonymous=False, log_level=None, disable_rostime=False, disable_rosout=False, disable_signals=False, xmlrpc_port=0, tcpros_port=0):    &quot;&quot;&quot;    在ROS master中注册节点    @param name: 节点名称，必须保证节点名称唯一，节点名称中不能使用命名空间(不能包含 &#x27;/&#x27;)    @type  name: str    @param argv: 命令行参数列表，通常传入sys.argv，用于处理启动参数    @type  argv: list    @param anonymous: 取值为 true 时，为节点名称后缀随机编号，允许多个同名节点同时运行    @type  anonymous: bool    @param log_level: 日志级别，可选值：rospy.DEBUG, rospy.INFO, rospy.WARN, rospy.ERROR, rospy.FATAL    @type  log_level: int    @param disable_rostime: 如果为 true，禁用ROS时间系统，使用系统时间而不是ROS时间    @type  disable_rostime: bool    @param disable_rosout: 如果为 true，禁用rosout日志系统，减少日志输出    @type  disable_rosout: bool    @param disable_signals: 如果为 true，禁用ROS信号处理，需要手动处理信号    @type  disable_signals: bool    @param xmlrpc_port: XML-RPC通信端口，0表示自动分配，用于与ROS master通信    @type  xmlrpc_port: int    @param tcpros_port: TCP-ROS通信端口，0表示自动分配，用于节点间通信    @type  tcpros_port: int    @raise ROSException: 如果节点初始化失败    @raise ROSNodeException: 如果节点名称无效或已存在    &quot;&quot;&quot;\n\n话题与服务相关对象Python1.发布对象对象获取:class Publisher(Topic):    &quot;&quot;&quot;    在ROS master注册为相关话题的发布方    &quot;&quot;&quot;    def __init__(self, name, data_class, subscriber_listener=None, tcp_nodelay=False, latch=False, headers=None, queue_size=None):        &quot;&quot;&quot;        Constructor        @param name: 话题名称，指定要发布的话题名称，不能为空        @type  name: str                @param data_class: 消息类型，指定要发布的消息类型，必须是ROS消息类        @type  data_class: 消息类        @param subscriber_listener: 订阅者监听器，用于监听订阅者的连接和断开事件        @type  subscriber_listener: SubscriberListener        @param tcp_nodelay: 如果为 true，启用TCP_NODELAY选项，减少网络延迟但可能增加网络负载        @type  tcp_nodelay: bool        @param latch: 如果为 true,该话题发布的最后一条消息将被保存，并且后期当有订阅者连接时会将该消息发送给订阅者        @type  latch: bool        @param headers: 消息头部信息，为消息添加默认的头部信息        @type  headers: dict        @param queue_size: 等待发送给订阅者的最大消息数量，控制内存使用和消息丢失        @type  queue_size: int        @raise ROSException: 如果发布者创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n消息发布函数:def publish(self, *args, **kwds):        &quot;&quot;&quot;        发布消息        &quot;&quot;&quot;\n\n2.订阅对象对象获取:class Subscriber(Topic):    &quot;&quot;&quot;    类注册为指定主题的订阅者，其中消息是给定类型的。    &quot;&quot;&quot;    def __init__(self, name, data_class, callback=None, callback_args=None,                 queue_size=None, buff_size=DEFAULT_BUFF_SIZE, tcp_nodelay=False):        &quot;&quot;&quot;        Constructor.        @param name: 话题名称，指定要订阅的话题名称，不能为空        @type  name: str                @param data_class: 消息类型，指定要订阅的消息类型，必须是ROS消息类        @type  data_class: L&#123;Message&#125; class                @param callback: 处理订阅到的消息的回调函数，当收到消息时自动调用        @type  callback: fn(msg, cb_args)        @param callback_args: 传递给回调函数的额外参数，用于向回调函数传递自定义数据        @type  callback_args: any        @param queue_size: 消息队列长度，超出长度时，头部的消息将被弃用，控制消息缓存大小        @type  queue_size: int        @param buff_size: 缓冲区大小，用于网络传输的缓冲区大小，影响网络性能        @type  buff_size: int        @param tcp_nodelay: 如果为 true，启用TCP_NODELAY选项，减少网络延迟但可能增加网络负载        @type  tcp_nodelay: bool        @raise ROSException: 如果订阅者创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n3.服务对象对象获取:class Service(ServiceImpl):    &quot;&quot;&quot;     声明一个ROS服务    使用示例::      s = Service(&#x27;getmapservice&#x27;, GetMap, get_map_handler)    &quot;&quot;&quot;    def __init__(self, name, service_class, handler,                 buff_size=DEFAULT_BUFF_SIZE, error_handler=None):        &quot;&quot;&quot;        Constructor        @param name: 服务主题名称，指定要创建的服务名称，不能为空        @type  name: str                @param service_class: 服务消息类型，指定服务的请求和响应消息类型        @type  service_class: L&#123;Service&#125; class        @param handler: 回调函数，处理请求数据，并返回响应数据，当收到服务请求时自动调用        @type  handler: fn(req)-&gt;resp        @param buff_size: 缓冲区大小，用于网络传输的缓冲区大小，影响网络性能        @type  buff_size: int        @param error_handler: 错误处理函数，当服务处理过程中发生错误时调用        @type  error_handler: fn(exception)-&gt;None        @raise ROSException: 如果服务创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n4.客户端对象对象获取:class ServiceProxy(_Service):    &quot;&quot;&quot;   创建一个ROS服务的句柄    示例用法::      add_two_ints = ServiceProxy(&#x27;add_two_ints&#x27;, AddTwoInts)      resp = add_two_ints(1, 2)    &quot;&quot;&quot;    def __init__(self, name, service_class, persistent=False, headers=None):        &quot;&quot;&quot;        ctor.        @param name: 服务主题名称，指定要调用的服务名称，不能为空        @type  name: str        @param service_class: 服务消息类型，指定服务的请求和响应消息类型        @type  service_class: Service class        @param persistent: 如果为 true，保持连接，避免重复建立连接的开销        @type  persistent: bool        @param headers: 消息头部信息，为服务请求添加默认的头部信息        @type  headers: dict        @raise ROSException: 如果服务代理创建失败        @raise ROSNodeException: 如果节点未初始化        &quot;&quot;&quot;\n\n请求发送函数:def call(self, *args, **kwds):        &quot;&quot;&quot;        发送请求，返回值为响应数据\t\t@param *args: 位置参数，按顺序传递服务请求的字段值        @type  *args: tuple        @param **kwds: 关键字参数，通过字段名传递服务请求的值        @type  **kwds: dict        @return: 服务响应对象，包含服务处理结果        @rtype: 响应消息类型        @raise ROSException: 如果服务调用失败        @raise ROSServiceException: 如果服务不存在或调用超时        &quot;&quot;&quot;\n\n等待服务函数:def wait_for_service(service, timeout=None):    &quot;&quot;&quot;    调用该函数时，程序会处于阻塞状态直到服务可用        @param service: 被等待的服务话题名称    @type  service: str   \t@param timeout: 超时时间    @type  timeout: double|rospy.Duration    &quot;&quot;&quot;\n","tags":["ROS"]},{"title":"[学习存档]URDF用法","url":"/2025/10/25/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DURDF%E8%AF%AD%E6%B3%95/","content":"robot属性\n\nname = &quot;名称&quot;\n  指定机器人模型的名称\n\n\nlink用于描述机器人某个部件(也即刚体部分)的外观和物理属性，机器人底座、轮子、激光雷达、摄像头等每一个部件都对应一个 link, 在 link 标签内，可以设计该部件的形状、尺寸、颜色、惯性矩阵、碰撞参数等一系列属性.\n属性\n\nname = &quot;名称&quot;\n  指定连杆的名称\n\n\norigin属性\n\nxyz=&quot;x y z&quot;\n  定义该 link 的位置，相对于其父 link 或全局坐标系\n\nrpy=&quot;roll pitch yaw&quot;\n  定义该 link 的旋转，使用滚动（roll）、俯仰（pitch）和偏航（yaw）角\n\n\ninertial\n定义该 link 的惯性属性，用于物理模拟。\n\n标签\n\n&lt;mass value = &quot;mass_value&quot;&gt;\n  定义该 link 的质量\n\n&lt;inertia ixx=&quot;ixx&quot; ixy=&quot;ixy&quot; ixz=&quot;ixz&quot; iyy=&quot;iyy&quot; iyz=&quot;iyz&quot; izz=&quot;izz&quot;&gt;\n  定义该 link 的惯性矩，包括六个分量：ixx, ixy, ixz, iyy, iyz, izz。\n\n\nvisual\n定义该 link 的视觉属性，用于渲染。\n&lt;origin&gt;：定义视觉几何形状的位置和旋转。\n&lt;geometry&gt;：定义视觉几何形状，可以是 box（盒子）、cylinder（圆柱）、sphere（球体）或 mesh（网格）。\n&lt;material&gt;：定义视觉材质，可以引用预定义的材质。\n\ngeometry标签\n\n&lt;box size=&quot;x y z&quot;&gt;\n  属性:size&#x3D;长(x) 宽(y) 高(z)\n\n&lt;cylinder radius=&quot;radius&quot; length=&quot;length&quot;&gt;\n  属性:radius&#x3D;半径 length&#x3D;高度\n\n&lt;sphere radius=&quot;radius&quot;&gt;\n  属性:radius&#x3D;半径\n\n&lt;mesh filename=&quot;filename&quot; scale=&quot;x y z&quot;&gt;\n  属性:filename&#x3D;文件路径 scale&#x3D;范围\n\n\norigin属性\n\norigin xyz=&quot;x y z&quot; rpy=&quot;roll pitch yaw&quot;\n  属性1: xyz&#x3D;偏移 偏移 偏移\n  属性2: rpy&#x3D;翻滚 俯仰 偏航 (单位是弧度)\n\n\nmetrial属性\n\nname = &quot;名称&quot;\n  指定材料的名称\n\n\n标签\n\n&lt;color rgba = &quot;r g b a&quot;&gt; \n  属性: rgba&#x3D;红绿蓝权重值与透明度 (每个权重值以及透明度取值[0,1])\n\n\ncollision\n定义该 link 的碰撞属性，用于物理模拟中的碰撞检测。\n&lt;origin&gt;：定义碰撞几何形状的位置和旋转。\n&lt;geometry&gt;：定义碰撞几何形状，可以是 box（盒子）、cylinder（圆柱）、sphere（球体）或 mesh（网格）。\n\njoint在 URDF（Unified Robot Description Format）中，joint 元素是机器人结构的连接单元，它定义两个 link 元素之间的连接方式和运动学&#x2F;动力学属性。通过 joint 可以描述机器人关节的类型、运动范围、惯性参数等，是实现机器人运动模拟和控制的关键。\n属性\n\nname = &quot;名称&quot;\n  指定关节的名称\n\ntype=&quot;形式&quot;\n  这是 joint 元素最关键的属性，不同类型需要不同的子元素。\n\n\n\n\n\n类型\n说明\n适用子元素\n适用场景\n\n\n\nfixed\n固定关节（不允许运动）\n无额外元素\n用于连接静态部件（如机器人底座、外壳等）\n\n\nrevolute\n旋转关节（绕一个轴旋转）\n&lt;axis&gt;, &lt;limit&gt;\n最常用的旋转关节（如机械臂关节、轮轴）\n\n\ncontinuous\n连续旋转关节（无限旋转，类似 revolute 但无限制）\n&lt;axis&gt;\n用于需要无限旋转的结构（如电机驱动轴、雷达平台）\n\n\nprismatic\n滑动关节（沿一个轴滑动）\n&lt;axis&gt;, &lt;limit&gt;\n用于线性滑动结构（如伸缩臂、升降机构、电梯导轨）\n\n\nplanar\n平面关节（在 XY 平面上自由平移和旋转）\n&lt;axis&gt;（通常不使用）\n用于平面移动平台或二维滑行机构（如移动滑台）\n\n\nfloating\n浮动关节（6 DOF，完全自由）\n无额外元素\n用于基座自由运动（如无人机、潜艇或自由浮动基座）\n\n\nball\n球关节（3 DOF，类似人体肩膀或髋关节）\n&lt;axis&gt;（通常不使用）\n用于需要球面旋转的连接（如仿人肩关节、球窝接头）\n\n\n标签\n\n&lt;parent&gt;base_link&lt;/parent&gt;\n  定义关节的父连接（必须有）\n\n&lt;child&gt;arm_link&lt;/child&gt;\n  定义关节的子连接（必须有）\n\n&lt;origin xyz=&quot;x y z&quot; rpy=&quot;roll pitch yaw&quot; /&gt;\n\nxyz：关节相对于父链接的平移向量（米）\nrpy：关节相对于父链接的旋转欧拉角（弧度）\n\n\n&lt;axis xyz=&quot;x y z&quot;\n  表示关节的运动轴（单位向量）\n\n&lt;axis xyz=&quot;x y z&quot;\n  表示关节的运动轴（单位向量）\n\n&lt;limit lower=&quot;l&quot; upper=&quot;u&quot; effort=&quot;e&quot; velocity=&quot;v&quot; /&gt;\n\n描述：定义关节的运动范围、速度和力矩限制。主要用于 revolute 和 prismatic 关节。\n参数：\nlower：最小角度（revolute）或最小滑动距离（prismatic）。\nupper：最大角度或最大滑动距离。\nvelocity：最大速度（弧度&#x2F;秒或米&#x2F;秒）。\neffort：最大力矩（牛顿米）或推力（牛顿）。\n\n\n&lt;dynamics damping=&quot;d&quot; friction=&quot;f&quot; /&gt;\n\n描述：定义关节的阻尼和摩擦系数，用于物理模拟（如 Gazebo）。\n参数：\ndamping：阻尼系数。\nfriction：摩擦系数。\n\n\n&lt;safety k_gain=&quot;100&quot; k_velocity=&quot;1.0&quot; k_position=&quot;1.0&quot; /&gt;\n\n描述：定义关节的安全控制参数，用于控制器（如 ros_control）防止过载。\n参数：\nk_gain：安全增益。\nk_velocity：速度安全系数。\nk_position：位置安全系数。\n\n\n\n示例与优化需求:创建机器人模型，底盘为长方体，在长方体的前面添加一摄像头，摄像头可以沿着 Z 轴 360 度旋转。\nURDF文件示例&lt;robot name=&quot;mycar&quot;&gt;    &lt;!-- 底盘 --&gt;    &lt;link name=&quot;base_link&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;box size=&quot;0.5 0.2 0.1&quot; /&gt;            &lt;/geometry&gt;            &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;            &lt;material name=&quot;blue&quot;&gt;                &lt;color rgba=&quot;0 0 1.0 0.5&quot; /&gt;            &lt;/material&gt;        &lt;/visual&gt;    &lt;/link&gt;    &lt;!-- 摄像头 --&gt;    &lt;link name=&quot;camera&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;box size=&quot;0.02 0.05 0.05&quot; /&gt;            &lt;/geometry&gt;            &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;            &lt;material name=&quot;red&quot;&gt;                &lt;color rgba=&quot;1 0 0 0.5&quot; /&gt;            &lt;/material&gt;        &lt;/visual&gt;    &lt;/link&gt;    &lt;!-- 关节 --&gt;    &lt;joint name=&quot;camera2baselink&quot; type=&quot;continuous&quot;&gt;        &lt;parent link=&quot;base_link&quot;/&gt;        &lt;child link=&quot;camera&quot; /&gt;        &lt;!-- 需要计算两个 link 的物理中心之间的偏移量 --&gt;        &lt;origin xyz=&quot;0.2 0 0.075&quot; rpy=&quot;0 0 0&quot; /&gt;        &lt;axis xyz=&quot;0 0 1&quot; /&gt;    &lt;/joint&gt;&lt;/robot&gt;\n\nlaunch文件示例&lt;launch&gt;    &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find urdf_rviz_demo)/urdf/urdf/urdf03_joint.urdf&quot; /&gt;    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find urdf_rviz_demo)/config/helloworld.rviz&quot; /&gt;     &lt;!-- 添加关节状态发布节点 --&gt;    &lt;node pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; name=&quot;joint_state_publisher&quot; /&gt;    &lt;!-- 添加机器人状态发布节点 --&gt;    &lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; name=&quot;robot_state_publisher&quot; /&gt;    &lt;!-- 可选:用于控制关节运动的节点(可选) --&gt;    &lt;node pkg=&quot;joint_state_publisher_gui&quot; type=&quot;joint_state_publisher_gui&quot; name=&quot;joint_state_publisher_gui&quot; /&gt;&lt;/launch&gt;\n\nbase_footprint优化前面实现的机器人模型是半沉到地下的，因为默认情况下底盘的中心点位于地图原点上。可以使用的优化策略：将初始 link 设置为一个尺寸极小的 link(比如半径为 0.001m 的球体，或边长为 0.001m 的立方体)，然后再在初始 link 上添加底盘等刚体，这样实现，虽然仍然存在初始link半沉的现象，但是基本可以忽略了。这个初始 link 一般称之为 base_footprint。\n&lt;!--    使用 base_footprint 优化--&gt;&lt;robot name=&quot;mycar&quot;&gt;    &lt;!-- 设置一个原点(机器人中心点的投影) --&gt;    &lt;link name=&quot;base_footprint&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;sphere radius=&quot;0.001&quot; /&gt;            &lt;/geometry&gt;        &lt;/visual&gt;    &lt;/link&gt;    &lt;!-- 添加底盘 --&gt;    &lt;link name=&quot;base_link&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;box size=&quot;0.5 0.2 0.1&quot; /&gt;            &lt;/geometry&gt;            &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;            &lt;material name=&quot;blue&quot;&gt;                &lt;color rgba=&quot;0 0 1.0 0.5&quot; /&gt;            &lt;/material&gt;        &lt;/visual&gt;    &lt;/link&gt;    &lt;!-- 底盘与原点连接的关节 --&gt;    &lt;joint name=&quot;base_link2base_footprint&quot; type=&quot;fixed&quot;&gt;        &lt;parent link=&quot;base_footprint&quot; /&gt;        &lt;child link=&quot;base_link&quot; /&gt;        &lt;origin xyz=&quot;0 0 0.05&quot; /&gt;    &lt;/joint&gt;    &lt;!-- 添加摄像头 --&gt;    &lt;link name=&quot;camera&quot;&gt;        &lt;visual&gt;            &lt;geometry&gt;                &lt;box size=&quot;0.02 0.05 0.05&quot; /&gt;            &lt;/geometry&gt;            &lt;origin xyz=&quot;0 0 0&quot; rpy=&quot;0 0 0&quot; /&gt;            &lt;material name=&quot;red&quot;&gt;                &lt;color rgba=&quot;1 0 0 0.5&quot; /&gt;            &lt;/material&gt;        &lt;/visual&gt;    &lt;/link&gt;    &lt;!-- 关节 --&gt;    &lt;joint name=&quot;camera2baselink&quot; type=&quot;continuous&quot;&gt;        &lt;parent link=&quot;base_link&quot;/&gt;        &lt;child link=&quot;camera&quot; /&gt;        &lt;origin xyz=&quot;0.2 0 0.075&quot; rpy=&quot;0 0 0&quot; /&gt;        &lt;axis xyz=&quot;0 0 1&quot; /&gt;    &lt;/joint&gt;&lt;/robot&gt;","tags":["ROS"]},{"title":"如何用TurtleBot 构建世界地图并实现红球定位","url":"/2025/10/30/%E5%A6%82%E4%BD%95%E7%94%A8TurtleBot%20%E6%9E%84%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%A2%E7%90%83%E5%AE%9A%E4%BD%8D/","content":"整体工作流程\n构建世界地图（使用SLAM）\n红球视觉识别（OpenCV识别红色目标）\n坐标转换（将像素坐标转换为世界坐标）\n获取自身位置（从 /odometry/turtlebot 话题）\n输出结果\n\n零、准备工作步骤1：安装 ROS 和相关包确保你已经安装了 ROS Noetic，并且安装了相关的依赖包。你可以按照以下命令安装：\nsudo apt updatesudo apt install ros-noetic-desktop-fullsudo apt install ros-noetic-turtlebot-gazebosudo apt install ros-noetic-turtlebot-navigationsudo apt install ros-noetic-cv-bridgesudo apt install ros-noetic-tfsudo apt install ros-noetic-navigation\n\n步骤2：创建一个 ROS 工作空间在 ROS 中，所有代码都需要放在一个工作空间中。你可以通过以下命令创建工作空间：\nmkdir -p ~/catkin_ws/srccd ~/catkin_wscatkin_make\n\n然后切换到工作空间：\ncd ~/catkin_ws/src\n\n步骤3：创建你的 ROS 包在 src 目录下创建一个新的 ROS 包 red_ball_detector：\ncatkin_create_pkg red_ball_detector rospy std_msgs sensor_msgs geometry_msgs nav_msgs cv_bridge tf\n\n这会为你创建一个基础的包结构。\n进入 red_ball_detector 包目录：\ncd ~/catkin_ws/src/red_ball_detector\n\n一、构建世界地图（SLAM）步骤1：启动仿真环境启动 Gazebo 仿真环境并加载 TurtleBot 机器人。\nroslaunch turtlebot_gazebo turtlebot_world.launch\n\n为了让 TurtleBot 能够在仿真中进行定位，我们需要启动 AMCL（自适应蒙特卡罗定位），它会使用地图进行定位。\nroslaunch turtlebot_navigation amcl_demo.launch\n\n通过 rviz 可视化机器人和地图。\nroslaunch turtlebot_rviz_launchers view_navigation.launch\n步骤2：构建地图roslaunch turtlebot_navigation gmapping_demo.launch\n\n启动后，机器人会开始在虚拟世界中移动，并通过 gmapping 构建地图。\n一旦地图构建完成，你可以保存该地图。按下 Ctrl+C 停止 gmapping，然后使用以下命令来保存地图：\nrosrun map_server map_saver -f ~/my_map\n\n这会保存地图文件到 ~/my_map.yaml 和 ~/my_map.pgm。将它们放到 config/ 目录中，后续将通过启动文件加载这些地图。\n步骤3：加载地图并进行定位我们加载保存的地图，并使用 amcl 进行定位。\nroslaunch turtlebot_navigation amcl_demo.launch map_file:=~/my_map.yaml\n\n\n二、红球视觉识别与定位原理\n识别红球 使用OpenCV在RGB图像中识别红色目标（HSV颜色空间）。\n获取深度值 通过深度相机（Kinect）获取红球在3D空间中的距离。\n坐标转换\n将像素坐标 → 相机坐标系\n通过TF 转换到世界坐标系（map）\n\n\n\n步骤1：创建ROS节点（Python）创建文件 red_ball_detector.py：\n#!/usr/bin/env python# -*- coding: utf-8 -*-import rospyimport cv2import numpy as npfrom cv_bridge import CvBridgefrom sensor_msgs.msg import Image, CameraInfofrom geometry_msgs.msg import PointStamped, PoseStampedfrom nav_msgs.msg import Odometryfrom tf import TransformListenerclass RedBallDetector:    def __init__(self):        rospy.init_node(&#x27;red_ball_detector&#x27;, anonymous=True)                # 初始化工具        self.bridge = CvBridge()        self.tf = TransformListener()                # 参数设置        self.camera_info = None        self.robot_odom = None  # 存储最新位姿                # 订阅话题        self.sub_image = rospy.Subscriber(&#x27;/camera/rgb/image_raw&#x27;, Image, self.image_callback)        self.sub_depth = rospy.Subscriber(&#x27;/camera/depth/image_raw&#x27;, Image, self.depth_callback)        self.sub_camera_info = rospy.Subscriber(&#x27;/camera/rgb/camera_info&#x27;, CameraInfo, self.camera_info_callback)        self.sub_odom = rospy.Subscriber(&#x27;/odometry/turtlebot&#x27;, Odometry, self.odom_callback)                # 发布话题        self.pub_ball_pose = rospy.Publisher(&#x27;/red_ball_pose&#x27;, PointStamped, queue_size=10)        self.pub_self_pose = rospy.Publisher(&#x27;/self_pose&#x27;, PoseStamped, queue_size=10)                # 等待相机内参        rospy.loginfo(&quot;Waiting for camera info...&quot;)        while not rospy.is_shutdown() and self.camera_info is None:            rospy.sleep(0.1)        rospy.loginfo(&quot;Camera info received!&quot;)                # 发布自身位置（每2秒发布一次）        self.pub_self_timer = rospy.Timer(rospy.Duration(2.0), self.publish_self_pose)        def camera_info_callback(self, msg):        &quot;&quot;&quot;获取相机内参（K矩阵）&quot;&quot;&quot;        self.camera_info = msg        self.K = np.array([            [msg.k[0], msg.k[1], msg.k[2]],            [msg.k[3], msg.k[4], msg.k[5]],            [msg.k[6], msg.k[7], msg.k[8]]        ])        self.cx = msg.k[2]   # 主点x        self.cy = msg.k[5]   # 主点y        self.fx = msg.k[0]   # 焦距x        self.fy = msg.k[4]   # 焦距y        def odom_callback(self, msg):        &quot;&quot;&quot;获取机器人当前位姿&quot;&quot;&quot;        self.robot_odom = msg        def publish_self_pose(self, event):        &quot;&quot;&quot;发布机器人当前位置（用于测试）&quot;&quot;&quot;        if self.robot_odom:            pose_stamped = PoseStamped()            pose_stamped.header = self.robot_odom.header            pose_stamped.pose = self.robot_odom.pose.pose            self.pub_self_pose.publish(pose_stamped)            self.log_pose(pose_stamped)        def log_pose(self, pose):        &quot;&quot;&quot;输出机器人位置&quot;&quot;&quot;        x = pose.pose.position.x        y = pose.pose.position.y        z = pose.pose.position.z        rospy.loginfo(f&quot;Self Position (Map Frame): x=&#123;x:.2f&#125;, y=&#123;y:.2f&#125;, z=&#123;z:.2f&#125;&quot;)        def image_callback(self, msg):        &quot;&quot;&quot;处理RGB图像（识别红球）&quot;&quot;&quot;        try:            cv_image = self.bridge.imgmsg_to_cv2(msg, &quot;bgr8&quot;)            # 识别红球，返回像素坐标和半径            center, radius = self.find_red_ball(cv_image)                        if center is not None and radius &gt; 10:  # 过滤小目标                u, v = center                rospy.loginfo(f&quot;Red ball detected at pixel: (&#123;u&#125;, &#123;v&#125;), radius=&#123;radius&#125;&quot;)                                # 获取深度值                depth = self.get_depth(u, v, msg.header)                if depth &gt; 0:                    # 将像素坐标转换为世界坐标                    point_map = self.pixel_to_map(u, v, depth, msg.header)                    if point_map:                        self.pub_ball_pose.publish(point_map)                        self.log_ball_pose(point_map)            else:                rospy.loginfo_throttle(5, &quot;No red ball detected or too small&quot;)                        except Exception as e:            rospy.logerr(&quot;Error in image callback: %s&quot; % e)        def get_depth(self, u, v, header):        &quot;&quot;&quot;获取深度图像中的深度值（单位：米）&quot;&quot;&quot;        # 深度图像话题：/camera/depth/image_raw（16位灰度图，单位mm）        # 注意：深度图像和RGB图像需对齐（TurtleBot已做对齐）        try:            depth_msg = rospy.wait_for_message(&#x27;/camera/depth/image_raw&#x27;, Image, timeout=0.1)            depth_cv = np.frombuffer(depth_msg.data, dtype=np.uint16).reshape(                depth_msg.height, depth_msg.width            )            depth_cv = depth_cv.astype(np.float32) / 1000.0  # 转换为米            depth = depth_cv[v, u]  # 注意：深度图像中[row, col] = [v, u]            return depth        except rospy.ROSException:            rospy.logwarn(&quot;Depth image not received!&quot;)            return 0.0        def find_red_ball(self, image):        &quot;&quot;&quot;        识别红色球体，返回圆心像素坐标和半径        返回：( (u, v), radius ) 或 (None, None)        &quot;&quot;&quot;        # 转换为HSV颜色空间        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)                # 定义红色范围（注意：红色在HSV中分为两段）        lower_red1 = np.array([0, 50, 50])    # 红色下限1        upper_red1 = np.array([10, 255, 255])  # 红色上限1        lower_red2 = np.array([160, 50, 50])   # 红色下限2        upper_red2 = np.array([180, 255, 255]) # 红色上限2                # 创建掩码        mask1 = cv2.inRange(hsv, lower_red1, upper_red1)        mask2 = cv2.inRange(hsv, lower_red2, upper_red2)        mask = cv2.bitwise_or(mask1, mask2)                # 平滑掩码（去噪声）        mask = cv2.GaussianBlur(mask, (5, 5), 0)                # 找轮廓        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)                if not contours:            return None, None                # 找最大的轮廓        largest_contour = max(contours, key=cv2.contourArea)        (x, y), radius = cv2.minEnclosingCircle(largest_contour)                # 过滤过小的目标        if radius &lt; 10:  # 半径小于10像素则忽略            return None, None                return (int(x), int(y)), int(radius)        def pixel_to_map(self, u, v, depth, header):        &quot;&quot;&quot;        将像素坐标转换为世界坐标系（map）        步骤：        1. 像素坐标 → 相机坐标系        2. 相机坐标系 → 世界坐标系（通过TF转换）        &quot;&quot;&quot;        try:            # 1. 像素坐标 → 相机坐标系（单位：米）            # 相机坐标系：Z轴指向前方，X轴右，Y轴下            X = (u - self.cx) * depth / self.fx            Y = (v - self.cy) * depth / self.fy            Z = depth                        # 创建点消息（在相机光学坐标系中）            point_cam = PointStamped()            point_cam.header = header            point_cam.point = geometry_msgs.msg.Point(X, Y, Z)                        # 2. 通过TF转换到世界坐标系（map）            point_map = self.tf.transformPoint(&quot;map&quot;, point_cam)            return point_map                except (tf.LookupException, tf.ConnectivityException) as e:            rospy.logerr(&quot;TF转换错误: %s&quot; % e)            return Noneif __name__ == &#x27;__main__&#x27;:    detector = RedBallDetector()    rospy.spin()\n\n编写 CMakeLists.txt：\ncmake_minimum_required(VERSION 3.0.2)project(red_ball_detector)find_package(catkin REQUIRED COMPONENTS  rospy  std_msgs  sensor_msgs  geometry_msgs  nav_msgs  cv_bridge  tf)catkin_package()include_directories(  $&#123;catkin_INCLUDE_DIRS&#125;)catkin_install_python(PROGRAMS  src/red_ball_detector.py  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)\n\n编写 package.xml：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;package format=&quot;2&quot;&gt;  &lt;name&gt;red_ball_detector&lt;/name&gt;  &lt;version&gt;0.0.0&lt;/version&gt;  &lt;description&gt;The red_ball_detector package&lt;/description&gt;  &lt;maintainer email=&quot;youremail@example.com&quot;&gt;Your Name&lt;/maintainer&gt;  &lt;license&gt;BSD&lt;/license&gt;  &lt;depend&gt;rospy&lt;/depend&gt;  &lt;depend&gt;std_msgs&lt;/depend&gt;  &lt;depend&gt;sensor_msgs&lt;/depend&gt;  &lt;depend&gt;geometry_msgs&lt;/depend&gt;  &lt;depend&gt;nav_msgs&lt;/depend&gt;  &lt;depend&gt;cv_bridge&lt;/depend&gt;  &lt;depend&gt;tf&lt;/depend&gt;&lt;/package&gt;\n\n创建启动文件 launch/red_ball_detector.launch：\n&lt;launch&gt;  &lt;!-- 启动红球检测节点 --&gt;  &lt;node name=&quot;red_ball_detector&quot; pkg=&quot;red_ball_detector&quot; type=&quot;red_ball_detector.py&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt;\n\n创建启动文件 launch/amcl_with_map.launch：\n&lt;launch&gt;  &lt;!-- 加载已保存的地图 --&gt;  &lt;param name=&quot;map_file&quot; value=&quot;$(find red_ball_detector)/config/my_map.yaml&quot; /&gt;    &lt;!-- 启动 amcl 节点进行定位 --&gt;  &lt;node pkg=&quot;amcl&quot; type=&quot;amcl&quot; name=&quot;amcl&quot; output=&quot;screen&quot;&gt;    &lt;param name=&quot;base_frame_id&quot; value=&quot;base_link&quot; /&gt;    &lt;param name=&quot;odom_frame_id&quot; value=&quot;odom&quot; /&gt;  &lt;/node&gt;&lt;/launch&gt;\n\n创建配置文件 config/camera_info.yaml：\ncamera_info:  K: [525.0, 0.0, 319.5, 0.0, 525.0, 239.5, 0.0, 0.0, 1.0]  # 相机内参矩阵  width: 640  height: 480  distortion_model: plumb_bob  D: [0.1, -0.25, 0.001, 0.001, 0.0]\n\n步骤2：运行节点在新终端中运行红球检测节点：\nrosrun your_package red_ball_detector.py\n\n\n三、查看结果1. 输出到终端运行节点后，你会在终端看到：\nSelf Position (Map Frame): x=2.45, y=1.80, z=0.00Red ball detected at pixel: (320, 240), radius=45Red Ball Position (Map Frame): x=3.12, y=2.05, z=0.25\n\n\nSelf Position：TurtleBot当前位置（世界坐标系）\nRed ball detected：红球在图像中的像素位置\nRed Ball Position：红球在世界坐标系中的位置\n\n2. 在RViz中可视化\n添加显示项：\n\nPublished Topic → 添加 /red_ball_pose（类型：PointStamped）\nPublished Topic → 添加 /self_pose（类型：PoseStamped）\n\n\n设置框架\n\n所有话题的 Fixed Frame 设置为 map\n\n\n效果\n\n红球位置会以红色点显示在地图上\nTurtleBot位置会以绿色三角形显示\n\n\n\n","tags":["ROS","CV"]},{"title":"[学习存档]Xacro：通过变量结合函数优化URDF","url":"/2025/10/27/%5B%E5%AD%A6%E4%B9%A0%E5%AD%98%E6%A1%A3%5DXacro%EF%BC%9A%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E7%BB%93%E5%90%88%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96URDF/","content":"为什么需要Xacro？概念Xacro 是 XML Macros 的缩写，是一种 XML 宏语言，是可编程的 XML。\n原理Xacro 可以声明变量，可以通过数学运算求解，使用流程控制控制执行顺序，还可以通过类似函数的实现，封装固定的逻辑，将逻辑中需要的可变的数据以参数的方式暴露出去，从而提高代码复用率以及程序的安全性。\n作用较之于纯粹的 URDF 实现，可以编写更安全、精简、易读性更强的机器人模型文件，且可以提高编写效率。\n如何使用Xacro?编写 Xacro 文件在使用Xacro生成URDF时，根标签robot中必须包含命名空间：xmlns:xacro=&quot;http://wiki.ros.org/xarco&quot;\n属性与算数运算&lt;!-- 属性定义 --&gt;&lt;xacro:property name=&quot;xxxx&quot; value=&quot;yyyy&quot;/&gt;\n\n&lt;!-- 属性调用 --&gt;$&#123;属性名称&#125;\n\n&lt;!-- 算数运算 --&gt;$&#123;数学表达式&#125;\n\n宏&lt;!-- 宏定义 --&gt;&lt;xacro:macro name=&quot;宏名称&quot; params=&quot;参数列表(多参数之间使用空格分隔)&quot;&gt;   &lt;!-- 宏内容 --&gt;   &lt;!-- 参数调用格式: $&#123;参数名&#125; --&gt;&lt;/xacro:macro&gt;\n\n&lt;!-- 宏调用 --&gt;&lt;xacro:宏名称 参数1=xxx 参数2=xxx/&gt;\n\n文件包含机器人由多部件组成，不同部件可能封装为单独的 Xacro 文件，最后再将不同的文件集成，组合为完整机器人——这可以使用文件包含实现。\n&lt;robot name=&quot;xxx&quot; xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;&gt;    &lt;xacro:include filename=&quot;my_base.xacro&quot; /&gt;    &lt;xacro:include filename=&quot;my_camera.xacro&quot; /&gt;    &lt;xacro:include filename=&quot;my_laser.xacro&quot; /&gt;    &lt;!-- 其他部件 --&gt;&lt;/robot&gt;\n\n集成launch文件方法1：先将 xacro 文件转换成 urdf 文件，然后集成先将 xacro 文件解析成 urdf 文件：\nrosrun xacro xacro xxx.xacro &gt; xxx.urdf\n\n然后再按照之前的集成方式直接整合 launch 文件：\n&lt;launch&gt;    &lt;param name=&quot;robot_description&quot; textfile=&quot;$xxxx.urdf&quot; /&gt;    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $xxxx.rviz&quot; /&gt;    &lt;node pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; name=&quot;joint_state_publisher&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; name=&quot;robot_state_publisher&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;joint_state_publisher_gui&quot; type=&quot;joint_state_publisher_gui&quot; name=&quot;joint_state_publisher_gui&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt;\n\n方法2：在 launch 文件中直接加载 xacro(建议使用)&lt;launch&gt;    &lt;!-- $(find xacro)/xacro 是在 ROS 启动文件中，找到 xacro 包的路径，然后执行包内的 xacro 可执行脚本 --&gt;    &lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro xxx.xacro&quot; /&gt;    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $xxxx.rviz&quot; /&gt;    &lt;node pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; name=&quot;joint_state_publisher&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; name=&quot;robot_state_publisher&quot; output=&quot;screen&quot; /&gt;    &lt;node pkg=&quot;joint_state_publisher_gui&quot; type=&quot;joint_state_publisher_gui&quot; name=&quot;joint_state_publisher_gui&quot; output=&quot;screen&quot; /&gt;&lt;/launch&gt;","tags":["ROS"]},{"title":"如果你下午四点钟来，那我在三点钟就会开始感到幸福。","url":"/2025/10/06/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9C%A8%E4%B8%8B%E5%8D%88%E5%9B%9B%E7%82%B9%E9%92%9F%E6%9D%A5%EF%BC%8C%E9%82%A3%E6%88%91%E5%9C%A8%E4%B8%89%E7%82%B9%E9%92%9F%E5%B0%B1%E4%BC%9A%E5%BC%80%E5%A7%8B%E6%84%9F%E5%88%B0%E5%B9%B8%E7%A6%8F%E3%80%82/","content":"该怎么去阐述演唱会的意义呢。我想于真正的歌迷而言，或者至少于我而言，演唱会从来都不只是两三个小时的大型乌托邦，是开票前请各种朋友帮忙的倾尽全力，是抢到票后提前一个月就时不时在内心彩排的预演快乐，是越逼近约定兑现之时越幸福的期待。这大概就是有所望的力量。我还记得2025年9月28日的武汉有多热——赶到场馆已是大汗淋漓。为了应援购入的联名卫衣外套没法穿，拥挤的内场想要拍照记录貌似也不如看台方便。或许我就是这么贪婪的。抢到票前总想着能进场就行，真的坐在内场了，总期待自己能比之前在看台离偶像更近一点，这次能不能看见人呢？答案是还是很远。于是便暗暗下定决心下次一定要买到2000的票。我之前一直对“人总是在接近幸福时最幸福”的说法表示不解，因为我总在幸福时依旧幸福。但这次坐在内场，看着我熟悉的流程一个一个进行下去，熟悉的常驻曲目响起，我确实感到自己并没有开场前幸福了。是太躁热吗？原因在爱你没差响起时明晰了。比较真的是偷走幸福的小偷。抢到票的我与没抢到票的我相比是幸福的，坐在内场后排被无数部举起的手机挡住视线的我与内场前排的观众相比是不幸福的，但听到了爱你没差现场版的我与之前的我相比，又确确实实是无比幸福的。校园里的桂花开了，走在路上很香。让我想起了小时候总喜欢拾落在地上的桂花，或装在盒子里或制成香囊。思绪回到过去，就好奇，到底是什么时候开始不止是听众，而是粉丝的呢？或许真的没有一个特定的日子。只想起初三时，mojito发行，住校的我是靠打电话收听新歌的，是真的很期待。也记得那天校园广播放了mojito，旋律响起时全班人都看向我。在初中同学的回忆里，我大概始终与喜欢周杰伦绑定在一起。谢谢你成为了我的几分之几。\n","tags":["随笔"]}]